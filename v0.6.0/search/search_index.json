{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Bartiq","text":""},{"location":"#intro","title":"Intro","text":"<p>Bartiq is a library that allows one to analyze quantum algorithms and calculate symbolic expressions for quantum resource estimates (QRE).</p>"},{"location":"#installation","title":"Installation","text":"<p>To install <code>bartiq</code> run: <code>pip install bartiq</code>. For more details follow instructions on the installation page.</p>"},{"location":"#quick-start","title":"Quick start","text":"<p>In Bartiq we take a quantum algorithm expressed as a collection of subroutines, each with its costs expressed as symbolic expressions, and compile it to get cost expression for the whole algorithm.</p> <p>As an example we use Alias Sampling \u2013\u00a0an algorithm proposed by Babbush et al.\u00a0\u29c9. Here's how it's depicted in the paper:</p> <p></p> <p>In order to quickly get started with <code>bartiq</code>, you can load Alias Sampling as an example routine and use it as follows (click here to download <code>alias_sampling_basic.json</code>):</p> <pre><code>import json\nfrom bartiq import compile_routine, evaluate\nfrom qref import SchemaV1\n\nwith open(\"alias_sampling_basic.json\", \"r\") as f:\n    routine_dict = json.load(f)\n\nuncompiled_routine = SchemaV1(**routine_dict)\ncompiled_routine = compile_routine(uncompiled_routine).routine\n\nassignments = {\"L\": 100, \"mu\": 10}\n\nevaluated_routine = evaluate(compiled_routine, assignments).routine gs\n</code></pre> <p>Now in order to inspect the results you can do:</p> <pre><code>print(compiled_routine.resources[\"T_gates\"].value)\nprint(evaluated_routine.resources[\"T_gates\"].value)\n</code></pre> <p>which returns both the symbolic expression for the T-count as well as the specific values of <code>L</code> and <code>mu</code>:</p> <pre><code>4*L + 8*L/multiplicity(2, L) + 4*mu + swap.O(log2(L)) - 8\nswap.O(log2(100)) + 832\n</code></pre>"},{"location":"#next-steps","title":"Next steps","text":"<ul> <li>For a more comprehensive step-by-step examples, please see tutorials.</li> <li>If you are interested in learning more about how <code>bartiq</code> works under the hood, please see the concepts tab in the menu.</li> <li>For common issues, please check troubleshooting section.</li> <li>You can find reference documentation for the public API of <code>bartiq</code>'s python package, please go to reference.</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#basic","title":"Basic","text":"<p>To install <code>bartiq</code> run:</p> <pre><code>pip install bartiq\n</code></pre> <p>Info</p> <p>If you wish to use the package's jupyter integrations, run <code>pip install \"bartiq[jupyter]\"</code> instead.</p>"},{"location":"installation/#from-source","title":"From Source","text":"<p>For a source install run:</p> <pre><code># Clone bartiq repo (you can use HTTP link as well)\ngit clone git@github.com:PsiQ/bartiq.git\ncd bartiq\npip install .\n</code></pre> <p>Info</p> <p>If you wish to use the package's jupyter integrations, run <code>pip install \".[jupyter]\"</code> instead.</p>"},{"location":"installation/#development","title":"Development","text":"<p>For development we recommend installing using <code>poetry</code>:</p> <pre><code>git clone git@github.com:PsiQ/bartiq.git\ncd bartiq\npip install poetry\npoetry install\n</code></pre> <p>Info</p> <p>If you wish to use the package's jupyter integrations, run <code>poetry install -E jupyter</code> instead.</p> <p>This will create a virtual environment for you and install all developer and docs dependencies within it.</p> <p>To enter this environment run:</p> <pre><code>poetry shell\n</code></pre>"},{"location":"installation/#tests","title":"Tests","text":"<p>To run the test suite, from the project root directory run:</p> <pre><code>poetry shell  # If not already in the venv\npytest\n</code></pre>"},{"location":"installation/#documentation","title":"Documentation","text":"<p>To build docs, from the project root directory run:</p> <pre><code>poetry shell  # If not already in the venv\nmkdocs serve\n</code></pre>"},{"location":"limitations/","title":"Known limitations","text":"<p>This page lists some prominent limitations and missing features. Please keep in mind that <code>bartiq</code> is currently under active development, so some of these might soon be resolved. For an up-to-date list of all planned features, please see the GitHub issues page\u00a0\u29c9.</p>"},{"location":"limitations/#balance-between-exact-and-approximate-costs","title":"Balance between exact and approximate costs","text":"<p>For some quantum algorithms, the expression for their cost might depend on the inputs. For example, the uncontrolled SWAP gate can be implemented with just 3 CNOTs (no T gates), but the controlled version requires using T gates, depending on the number of controls. This effectively introduces a conditional cost. It can be modelled using bartiq in a couple of ways: - using a step function (Heaviside theta) allows to model cases where the cost has different values depending if given parameter is below or above certain threshold. - using piecewise sympy function\u00a0\u29c9 - using user-defined functions instead of sympy expressions</p> <p>However, all these methods introduce additional complexities which may or may not be appropriate for a given use-case. Ultimately, bartiq does not provide any native approach for dynamic definition of routines based on the topology, so users are responsible for such decision-making prior to compilation.</p>"},{"location":"limitations/#qubit-counts","title":"Qubit counts","text":"<p>While finding the size of a particular port/register in bartiq is simple, getting the full qubit count needed for a given algorithm is currently not something that bartiq natively supports, and rather requires such expressions to be defined by user-provided expressions. This is because there are typically subtleties involving counting ancillary qubits which are difficult or impossible to automate, such as algorithmic design choices concerning clean or dirty qubit reuse, etc. </p> <p>(N.B. we hope to support automatic qubit cost tabulation in the future, and so have included <code>qubits</code> as one of the native cost types, although at present it's not being used in any meaningful way.)</p>"},{"location":"limitations/#keeping-track-of-where-given-register-is-being-used","title":"Keeping track of where given register is being used","text":"<p>Bartiq operates purely on ports and connections between routines and hence does not have a concept of persistent qubits registers which exist beyond a single connection. This gives more flexibility in connecting routines and not having to deal with qubits allocation and deallocation. However, it also means that it is not natively possible to query whether the qubits referenced by a given connection correspond to any persistent quantum register or variable.</p>"},{"location":"limitations/#repeated-subroutines","title":"Repeated subroutines","text":"<p>Currently bartiq has limited capability to support a case where a particular subroutine is repeated multiple times. It can be done for a simple case where all the repetitions act on the same qubit registers. However, routines where target register change or we have a recursive definition (such as controlled unitaries in QPE) are not something one can natively support in Bartiq.</p>"},{"location":"reference/","title":"API reference","text":""},{"location":"reference/#bartiq","title":"bartiq","text":""},{"location":"reference/#bartiq.PortDirection","title":"PortDirection","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>Class for representing port direction.</p>"},{"location":"reference/#bartiq.ResourceType","title":"ResourceType","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>Class for representing types of resources.</p>"},{"location":"reference/#bartiq.compile_routine","title":"compile_routine","text":"<pre><code>compile_routine(\n    routine: SchemaV1 | RoutineV1 | Routine[T],\n    *,\n    backend: SymbolicBackend[T] = sympy_backend,\n    preprocessing_stages: Iterable[\n        PreprocessingStage[T]\n    ] = DEFAULT_PREPROCESSING_STAGES,\n    skip_verification: bool = False\n) -&gt; CompilationResult[T]\n</code></pre> <p>Performs symbolic compilation of a given routine.</p> <p>In this context, compilation means transforming a routine defined in terms of routine-local variables into one defined in terms of global input parameters.</p> <p>Parameters:</p> Name Type Description Default <code>routine</code> <code>SchemaV1 | RoutineV1 | Routine[T]</code> <p>routine to be compiled.</p> required <code>backend</code> <code>SymbolicBackend[T]</code> <p>a backend used for manipulating symbolic expressions.</p> <code>sympy_backend</code> <code>preprocessing_stages</code> <code>Iterable[PreprocessingStage[T]]</code> <p>functions used for preprocessing of a given routine to make sure it can be correctly compiled by Bartiq.</p> <code>DEFAULT_PREPROCESSING_STAGES</code> <code>skip_verification</code> <code>bool</code> <p>a flag indicating whether verification of the routine should be skipped.</p> <code>False</code>"},{"location":"reference/#bartiq.evaluate","title":"evaluate","text":"<pre><code>evaluate(\n    compiled_routine: CompiledRoutine[T],\n    assignments: Assignments[T],\n    *,\n    backend: SymbolicBackend[T] = sympy_backend,\n    functions_map: FunctionsMap[T] | None = None\n) -&gt; EvaluationResult[T]\n</code></pre> <p>Substitutes variables into compiled routine.</p> <p>Parameters:</p> Name Type Description Default <code>compiled_routine</code> <code>CompiledRoutine[T]</code> <p>a compiled routine to be evaluated.</p> required <code>assignments</code> <code>Assignments[T]</code> <p>a dictionary mapping a subset of input params of <code>compiled_routine</code> either into concrete values, or other expressions. Expressions can be provided either as concrete instances of symbolic expressions understood by backend, or via strings, e.g. `{\"N\": 2, \"M\": \"k+3\"}.</p> required <code>backend</code> <code>SymbolicBackend[T]</code> <p>a backend used for manipulating symbolic expressions.</p> <code>sympy_backend</code> <code>functions_map</code> <code>FunctionsMap[T] | None</code> <p>a dictionary mapping function names to their concrete implementations.</p> <code>None</code> <p>Returns:</p> Type Description <code>EvaluationResult[T]</code> <p>A new instance of CompiledRoutine with appropriate substitutions made.</p>"},{"location":"reference/#bartiq.analysis","title":"bartiq.analysis","text":""},{"location":"reference/#bartiq.analysis.BigO","title":"BigO","text":""},{"location":"reference/#bartiq.analysis.BigO.__init__","title":"__init__","text":"<pre><code>__init__(expr: Expr, variable: Symbol | None = None)\n</code></pre> <p>Class for representing expressions in Big O notation.</p> <p>It analyzes given expression and returns all the Big O terms in it. If variable is provided, it analyses scaling in this particular variable, otherwise it assumes all the symbols are variables.</p> Note <p>It's an experimental tool and is meant to facilitate the analysis, but it might not produce correct results, especially for more complicated expressions. In case of any problems please create an issue on project's GitHub, we'd love to hear your feedback on this!</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr</code> <p>sympy expression we want to analyze</p> required <code>variable</code> <code>Symbol | None</code> <p>variable for which we want to performa analysis.</p> <code>None</code>"},{"location":"reference/#bartiq.symbolics","title":"bartiq.symbolics","text":""},{"location":"reference/#bartiq.errors","title":"bartiq.errors","text":""},{"location":"reference/#bartiq.errors.BartiqCompilationError","title":"BartiqCompilationError","text":"<p>             Bases: <code>Exception</code></p> <p>Raised for errors during Bartiq function compilation.</p>"},{"location":"reference/#bartiq.errors.BartiqPrecompilationError","title":"BartiqPrecompilationError","text":"<p>             Bases: <code>Exception</code></p> <p>Raised for errors during Bartiq function pre-compilation.</p>"},{"location":"reference/#bartiq.integrations","title":"bartiq.integrations","text":""},{"location":"reference/#bartiq.integrations.routine_to_latex","title":"routine_to_latex","text":"<pre><code>routine_to_latex(\n    routine: SchemaV1 | RoutineV1,\n    show_non_root_resources: bool = True,\n) -&gt; str\n</code></pre> <p>Returns a snippet of LaTeX used to render the routine using clear LaTeX.</p> <p>Parameters:</p> Name Type Description Default <code>routine</code> <code>SchemaV1 | RoutineV1</code> <p>The routine to render.</p> required <code>show_non_root_costs</code> <p>If <code>True</code> (default), displays all costs, otherwise only includes costs from the root node.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A LaTeX snippet of the routine.</p>"},{"location":"reference/#bartiq.transform","title":"bartiq.transform","text":""},{"location":"reference/#bartiq.transform.add_aggregated_resources","title":"add_aggregated_resources","text":"<pre><code>add_aggregated_resources(\n    routine: Routine[T],\n    aggregation_dict: dict[str, dict[str, Any]],\n    remove_decomposed: bool = True,\n    backend: SymbolicBackend[T] = sympy_backend,\n) -&gt; Routine[T]\n</code></pre> <p>Add aggregated resources to bartiq routine based on the aggregation dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>routine</code> <code>Routine[T]</code> <p>The program to which the resources will be added.</p> required <code>aggregation_dict</code> <code>dict[str, dict[str, Any]]</code> <p>A dictionary that decomposes resources into more fundamental components along with their</p> required <code>remove_decomposed</code> <p>Whether to remove the decomposed resources from the routine. Defaults to True.</p> <code>True</code> <code>backend</code> <p>Backend instance to use for handling expressions. Defaults to <code>sympy_backend</code>.</p> <code>sympy_backend</code> <p>Returns:</p> Name Type Description <code>Routine</code> <code>Routine[T]</code> <p>The program with aggregated resources.</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>Debugging <code>bartiq</code> is not always straightforward, so please see below for a number of best practices and common issues:</p> <ul> <li> <p>Bartiq routines can get pretty complicated very quickly, especially if nested subroutines are involved. Therefore when you get an error, try isolating the issue and work on a smaller example:</p> <ul> <li>First make sure that each child subroutine compiles correctly on its own. If not, this might suggest where the issue is.</li> <li>Try removing all the unnecessary fields, children, connections, etc. and prepare a minimal failing example.</li> </ul> </li> <li> <p>Take a look at the list of issues on GitHub\u00a0\u29c9 and see if other didn't have a similar problem!</p> <ul> <li>If not, consider creating one!</li> <li>Submitting issue is the most transparent way to give us feedback \u2013 even if something works, but is extremely unintuitive, we want to make it easier to use. The goal of this tool is to save you time, not waste it on unhelpful error messages.</li> </ul> </li> </ul>"},{"location":"concepts/compilation/","title":"Compilation","text":"<p>Here we will describe how the compilation process in Bartiq works. Please keep in mind, that while we try to keep this page up-to-date, in the end the code is the only source-of-truth. If you notice any discrepancies, between what's described here and how Bartiq behaves, please create an issue\u00a0\u29c9!</p>"},{"location":"concepts/compilation/#birds-eye-perspective-on-compilation","title":"Bird's eye perspective on compilation","text":"<p>Compilation is a very overloaded word, so let us start by explaining what we mean by compiling a routine in Bartiq.</p> <p>Quantum programs are often deeply nested structures. A program can call multiple routines, which themselves call other routines, and so on. One typically defines resources of each routine at the local level using available local symbols and variables. However, in the end, we are typically interested in resources used by each routine expressed in terms of input parameters of the whole program.</p> <p>Here's an example to illustrate what we're talking about. Below we show a routine with two children, each of them having some example resource defined in terms of their local parameters.</p> <pre><code>version: v1\nprogram:\n  name: root\n  input_params:\n  - N\n  ports:\n  - {\"name\": \"in_0\", \"size\": \"N\", \"direction\": \"input\"}\n  - {\"name\": \"out_0\", \"size\": null, \"direction\": \"output\"}\n  resources:\n  - {\"name\": \"x\", \"value\": \"a.x + b.x\", \"type\": \"additive\"}\n  children:\n    - name: \"a\"\n      ports:\n      - {\"name\": \"in_0\", \"size\": \"L\", \"direction\": \"input\"}\n      - {\"name\": \"out_0\", \"size\": \"2 * L\", \"direction\": \"output\"}\n      resources:\n      - {\"name\": \"x\", \"value\": \"L**2\", \"type\": \"additive\"}\n    - name: \"b\"\n      ports:\n      - {\"name\": \"in_0\", \"size\": \"L\", \"direction\": \"input\"}\n      - {\"name\": \"out_0\", \"size\": \"2 * L\", \"direction\": \"output\"}\n      resources:\n      - {\"name\": \"x\", \"value\": \"L ** 2\", \"type\": \"additive\"}\n  connections:\n    - in_0 -&gt; a.in_0\n    - a.out_0 -&gt; b.in_0\n    - b.out_0 -&gt; out_0  \n</code></pre> <p></p> <p>As we can see, both <code>a</code> and <code>b</code> have a resource <code>x</code> defined relatively to their input port size <code>L</code>. However, when looked globally, those resources would have a different value. Indeed, let's see how the port sizes propagate.</p> <ol> <li>The input port of the top-level <code>root</code> routine of size <code>N</code> is connected to the input port of routine <code>a</code>. Hence,    when viewed through global scope, the input port of <code>a</code> has size <code>N</code>.</li> <li>The output port of routine <code>a</code> has, by definition, size twice as large as its input port. It is connected to input port    of routine <code>b</code>, and therefore <code>b.in_0</code> has size <code>2N</code>.</li> </ol> <p>Looking at the resources of <code>a</code> and <code>b</code> we see that <code>x</code> is defined as square of their respective input port sizes. Thus, <code>a.x</code> has value of <code>N ** 2</code>, and <code>b.x</code> has value <code>(2 * N) ** 2 = 4 * N ** 2</code>.</p> <p>This is what the compilation process is all about. Given a routine with all its components defined in terms of local symbols and parameters, Bartiq produces a compiled routine in which all port sizes and resources are defined in terms of the global input symbols of top-level routine.</p>"},{"location":"concepts/compilation/#compilation-in-details","title":"Compilation in details","text":"<p>Compilation can be viewed as recursive process. At every recursive call, several things need to happen in correct order. Below we outline how the compilation proceeds.</p>"},{"location":"concepts/compilation/#step-1-preprocessing","title":"Step 1: preprocessing","text":"<p>The Bartiq's compilation engine makes several assumptions about the routine being compiled, which simplify its code at the expense of flexibility. For instance, Bartiq assumes all port sizes are single parameters of size <code>#port_name</code>. Another, very important assumption, is that there are no parameter links reaching deeper than one level of nesting.</p> <p>Writing a routine conforming to those requirements by hand is possible, but tedious. Instead, Bartiq allows for violation of some of its assumptions, and preprocesses the routine so that all the requirements are met.</p> <p>As an example, suppose some port <code>in_0</code> has size <code>1</code>. Bartiq replaces this size with <code>#in_0</code>, and then adds a constraint saying that <code>#in_0 = 1</code>.</p> <p>Currently, there are following preprocessing stages:</p> <ol> <li>Introduction of default additive resources. This stage allows users to define the additive resources for leafs,    and then adds the same resource to each of the higher-level routines, by defining it as a sum of the resource over all children that define it.    In the example we discussed previously, this preprocessing step would allow uas to skip the definition of    <code>x</code> resoruce in <code>root</code> and instead have it automatically defined by Bartiq.</li> <li>Propagation of linked params. In this stage all linked parameters reaching further than to the direct    descendant are converted into a series of direct parameter links. This is useful, because you can e.g.    link parameter from the top-level routine to a parameter arbitrarily deep in the program structure,    and it will still work, despite Bartiq's compilation engine requirement on having only direct links.</li> <li>Promotion of ulinked inputs. Compilation cannot handle parameters that are not linked or pased through    connections. To avoid unnecessary compilation errors, Bartiq will promote such parameter to a parameter    linked to newly introduced parent's input.</li> <li>Introduction of port variables. As discussed above, this step converts all ports so that they have sizes    equal to a single-parameter expression of known name, while also introducing constraints to make sure    that no information is lost in the process.</li> </ol> <p>It is hopefully clear by now that preprocessing allows user for writing more concise and readable routines, while at the same time ensuring that strict requirements of compilation engine are met.</p>"},{"location":"concepts/compilation/#step-2-recursive-compilation-of-routines","title":"Step 2: Recursive compilation of routines","text":"<p>As already mentioned, the compilation process is recursive. While Bartiq processes any given routine, it maintains a parameter map for all the routine's children. This map gets populated whenever new piece of information is obtained, and then passed to the recursive call when each child is being compiled.</p>"},{"location":"concepts/compilation/#step-21-compilation-of-constraints","title":"Step 2.1: Compilation of constraints","text":"<p>At the very beginning of the compilation, Bartiq evaluates the constraints introduced in preprocessing. If any of the constraints is violated, a <code>BartiqCompiilationError</code> is raised. Constraints that are trivially satisfied are dropped from the system, and other constraints are retained.</p>"},{"location":"concepts/compilation/#step-22-compilation-of-local-variables","title":"Step 2.2: Compilation of local variables","text":"<p>As the next step, local variables of the routine are expressed in terms of variables passed from its parent (this step does nothing for the root routine). As the result, all local variables are expressed in terms of global parameters.</p>"},{"location":"concepts/compilation/#step-23-compilation-of-non-output-ports","title":"Step 2.3: Compilation of non-output ports","text":"<p>Input and through port sizes of any routine can only depend on its inputs and local variables. Thus, those objects are perfect to be compiled next.</p> <p>After each port is compiled, Bartiq checks if this port is connected to other port in the routine. If so, a corresponding entry in parameter tree is added. For instance, suppose that port <code>in_0</code> got compiled and has now size <code>N</code>. If this port is connected to port <code>in_1</code> of child <code>a</code>, a parameter map for <code>a</code> will contain entry mapping <code>#in_1</code> to <code>N</code>.</p>"},{"location":"concepts/compilation/#step-24-recursive-compilation-of-children","title":"Step 2.4: Recursive compilation of children","text":"<p>The children are traversed in topological order, which ensures all required entries in the parameter maps are populated before other children are compiled.</p> <p>Once this step is completed, we can be sure that all resources and ports of each child are expressed in terms of global variables, which is a requirement for the next step.</p>"},{"location":"concepts/compilation/#step-25-resource-compilation","title":"Step 2.5: Resource compilation","text":"<p>Resources of the routine are compiled, which is possible only at this stage, as they can be expressed in terms of resources of its children.</p>"},{"location":"concepts/compilation/#step-26-output-port-compilation","title":"Step 2.6: Output port compilation","text":"<p>Finally, the output ports are compiled, and the new object representing compiled routine is created.</p>"},{"location":"concepts/data_format/","title":"Data format","text":""},{"location":"concepts/evaluation/","title":"Evaluation","text":""},{"location":"concepts/symbolics/","title":"Symbolics","text":""},{"location":"tutorials/","title":"Introduction","text":"<p>We currently have three tutorials for <code>bartiq</code>:</p> <ul> <li>Basic example</li> <li>Alias Sampling basic</li> <li>Advanced examples</li> </ul> <p>They have been designed to gradually introduce you to the concepts we use in <code>bartiq</code>, so we recommend to go through them in order.</p>"},{"location":"tutorials/01_basic_example/","title":"Basic example","text":"<p>In this tutorial our goals are to learn:</p> <ul> <li>How to use <code>bartiq</code> to implement a quantum algorithm from a paper.</li> <li>How to obtain resource estimates for that algorithm.</li> <li>What the most important concepts used in <code>bartiq</code> are.</li> </ul> <p>NOTE:</p> <p>This tutorial, as well as all the other tutorials, has been written as a jupyter notebook. If you're reading it online, you can either keep reading, or go to <code>docs/tutorials</code> to explore them in a more interactive way!</p> <p>Before we start implementing some real algorithms, let's consider the following simple routine:</p> <p></p> <p>In <code>bartiq</code> the basic concept for representing both the whole algorithm as well as all the building blocks is routine. So what do we know about the routines from the picture above?</p> <ul> <li>Our main routine is called \"my algorithm\"</li> <li>It consists of two subroutines: \"A\" and \"B\".</li> <li>It takes in a register of size \"n\".</li> </ul> <p>How do we express this in <code>bartiq</code>? We do that using the <code>QREF</code> format\u00a0\u29c9 \u2013 a format for expressing algorithms that we developed with QREs in mind. So let's write our first routine:</p> In\u00a0[1]: Copied! <pre>my_algorithm = {\n    \"name\": \"my_algorithm\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"in\", \"direction\": \"input\", \"size\": \"n\"},\n        {\"name\": \"out\", \"direction\": \"output\", \"size\": None},\n    ],\n}\n</pre> my_algorithm = {     \"name\": \"my_algorithm\",     \"type\": None,     \"ports\": [         {\"name\": \"in\", \"direction\": \"input\", \"size\": \"n\"},         {\"name\": \"out\", \"direction\": \"output\", \"size\": None},     ], } <p>What do we have here?</p> <ul> <li><code>name</code>: name of the routine</li> <li><code>type</code>: in this case we don't define the type, but in more complex algorithms you might want to add types, such as \"basic_gate\" or \"comparator\".</li> <li><code>ports</code>: ports define the interface of the routine. The size of the input port is equal to <code>n</code> and in general, we won't know the size of the output port until we perform the compilation.</li> </ul> <p>What are we missing? Children.</p> <p>Before we add them to the main routine we need to define them though.</p> In\u00a0[2]: Copied! <pre>routine_a = {\n    \"name\": \"A\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"in\", \"direction\": \"input\", \"size\": \"n_a\"},\n        {\"name\": \"out\", \"direction\": \"output\", \"size\": \"2*n_a\"},\n    ],\n}\n</pre> routine_a = {     \"name\": \"A\",     \"type\": None,     \"ports\": [         {\"name\": \"in\", \"direction\": \"input\", \"size\": \"n_a\"},         {\"name\": \"out\", \"direction\": \"output\", \"size\": \"2*n_a\"},     ], } <p>Notice, that the sizes of input and output ports don't need to match. Here we defined that the size of the output port is twice the size of the input.</p> In\u00a0[3]: Copied! <pre>routine_b = {\n    \"name\": \"B\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"in\", \"direction\": \"input\", \"size\": \"n_b\"},\n         # \"y\" will be defined in the next step\n        {\"name\": \"out\", \"direction\": \"output\", \"size\": \"n_b + y\"},\n    ],\n}\n</pre> routine_b = {     \"name\": \"B\",     \"type\": None,     \"ports\": [         {\"name\": \"in\", \"direction\": \"input\", \"size\": \"n_b\"},          # \"y\" will be defined in the next step         {\"name\": \"out\", \"direction\": \"output\", \"size\": \"n_b + y\"},     ], } <p>We will need to know how much each subroutine costs if we want to run the resource estimation. In fault-tolerant quantum computation a common metric of interest is an algorithm's T-gate count (T-gates are a particular quantum gate which are typically more expensive to implement than other quantum gates, and so are commonly used as the standard metric for an algorithm's computational cost.)</p> <p>In this example, let's say that routine <code>A</code> costs <code>2*n_a + x</code> T gates and routine <code>B</code> costs <code>n_b*ceil(log_2(n_b)) * y</code> T-gates, where <code>x</code> and <code>y</code> are some arbitrary paremeters.</p> <p>Knowing T-gate costs and sizes of parameters, we can now visualize subroutines <code>A</code> and <code>B</code> like this:</p> <p></p> <p>This will require adding two new fields to the dictionaries defining <code>A</code> and <code>B</code> respectively:</p> In\u00a0[4]: Copied! <pre># Define T-gate counts for routine a\nroutine_a[\"input_params\"] = [\"x\"]\nroutine_a[\"resources\"] = [\n    {\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"2*n_a + x\"}\n]\n\n# Define T-gate counts for routine b\nroutine_b[\"input_params\"] = [\"y\"]\nroutine_b[\"resources\"] = [\n    {\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"n_b*ceil(log_2(n_b)) * y\"}\n]\n</pre> # Define T-gate counts for routine a routine_a[\"input_params\"] = [\"x\"] routine_a[\"resources\"] = [     {\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"2*n_a + x\"} ]  # Define T-gate counts for routine b routine_b[\"input_params\"] = [\"y\"] routine_b[\"resources\"] = [     {\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"n_b*ceil(log_2(n_b)) * y\"} ] <p>As you can see we added two new fields to our dictionaries:</p> <ul> <li><code>input_params</code>: which defines the variables used by the routine's resource expressions.</li> <li><code>resources</code>: which defines the resource costs for our routine. As you can see resources have the following fields:<ul> <li><code>name</code>: name of the resource</li> <li><code>type</code>: <code>qref</code> allows for the following types: <code>additive</code>, <code>multiplicative</code>, <code>qubits</code> and <code>other</code>.</li> <li><code>value</code>: expression (or numeric value) defining the cost.</li> </ul> </li> </ul> <p>Now that <code>routine_a</code> and <code>routine_b</code> are complete, we can add the missing components to <code>my_algorithm</code>:</p> In\u00a0[5]: Copied! <pre>my_algorithm[\"children\"] = [routine_a, routine_b]\nmy_algorithm[\"connections\"] = [\n    {\"source\": \"in\", \"target\": \"A.in\"},\n    {\"source\": \"A.out\", \"target\": \"B.in\"},\n    {\"source\": \"B.out\", \"target\": \"out\"},\n]\nmy_algorithm[\"input_params\"] = [\"z\"]\nmy_algorithm[\"linked_params\"] = [{\"source\": \"z\", \"targets\": [\"A.x\", \"B.y\"]}]\n</pre> my_algorithm[\"children\"] = [routine_a, routine_b] my_algorithm[\"connections\"] = [     {\"source\": \"in\", \"target\": \"A.in\"},     {\"source\": \"A.out\", \"target\": \"B.in\"},     {\"source\": \"B.out\", \"target\": \"out\"}, ] my_algorithm[\"input_params\"] = [\"z\"] my_algorithm[\"linked_params\"] = [{\"source\": \"z\", \"targets\": [\"A.x\", \"B.y\"]}] <p>The new things we have here are:</p> <ul> <li><code>connections</code>: defines how routines are connected via their ports. Each connection has source and target.</li> <li><code>children</code>: defines a routine's subroutines.</li> <li><code>linked_params</code>: defines how input parameters used by the parent are linked to the parameters of children. In this case, it specifies that the input parameter <code>z</code> should be passed as <code>x</code> to the subroutine <code>A</code> and as <code>y</code> to <code>B</code>. Note that we don't need to pass information about <code>n</code>, <code>n_a</code> and <code>n_b</code>, as this information gets passed through the connections.</li> </ul> <p>The last step is just a formality to indicate which version of QREF schema we use:</p> In\u00a0[6]: Copied! <pre>my_algorithm_qref_dict = {\"version\": \"v1\", \"program\": my_algorithm}\n</pre> my_algorithm_qref_dict = {\"version\": \"v1\", \"program\": my_algorithm} <p>Since it's more convenient to use a <code>pydantic</code> model rather than raw dictionary, we'll convert it:</p> In\u00a0[7]: Copied! <pre>from qref import SchemaV1\nmy_algorithm_qref = SchemaV1(**my_algorithm_qref_dict)\n</pre> from qref import SchemaV1 my_algorithm_qref = SchemaV1(**my_algorithm_qref_dict) <p>So, is there an intuitive way to understand what my algorithm looks like and how the resources are used in each routine? You can use the visualization tool from <code>QREF</code>\u00a0\u29c9 to plot the hierarchical Directed Acyclic Graph (DAG) of the algorithm you wrote.</p> <p>NOTE:</p> <p>         To use the qref\u00a0\u29c9 rendering tool in Jupyter Notebook, ensure the Graphviz software is installed on your OS and that its executables are included in your system variables. For installation instructions, please refer to the Graphviz download page\u00a0\u29c9.     </p> <p>Then, run: </p> In\u00a0[8]: Copied! <pre>from qref.experimental.rendering import to_graphviz\n\n# Convert the qref format to Graphviz object\ngv_object = to_graphviz(my_algorithm_qref)\n\n# Render the Graphviz object to a PNG file\ngv_object.render(\"my_algorithm\", format=\"png\")\n\n# Render the Graphviz object in the notebook\ngv_object\n</pre> from qref.experimental.rendering import to_graphviz  # Convert the qref format to Graphviz object gv_object = to_graphviz(my_algorithm_qref)  # Render the Graphviz object to a PNG file gv_object.render(\"my_algorithm\", format=\"png\")  # Render the Graphviz object in the notebook gv_object Out[8]: <p>In this graph, you can see both subroutines from the original algorithm, along with their <code>names</code> and<code>ports</code>. It provides a general idea of the connectivity between subroutines in the algorithm and shows how information is stored.</p> <p>Below you can find depiction of the uncompiled version of <code>my_algorithm</code>. </p> <p>What does \"uncompiled\" means here?</p> <p>It means that all the costs and register sizes are expressed using local variables (as in the picture above). What does it mean? Look at this:</p> In\u00a0[9]: Copied! <pre>uncompiled_routine = my_algorithm_qref.program\nuncompiled_routine.children.by_name[\"A\"].resources\n</pre> uncompiled_routine = my_algorithm_qref.program uncompiled_routine.children.by_name[\"A\"].resources Out[9]: <pre>[ResourceV1(name='T_gates', type='additive', value='2*n_a + x')]</pre> <p>The cost of <code>A</code> is still expressed in terms of its own \"local\" variables, <code>n_a</code> and <code>x</code>. Information that we included in <code>linked_params</code> has not yet been propagated into <code>A</code>.</p> <p>We also don't know yet what's the size of the output port:</p> In\u00a0[10]: Copied! <pre>uncompiled_routine.ports.by_name[\"out\"]\n</pre> uncompiled_routine.ports.by_name[\"out\"] Out[10]: <pre>PortV1(name='out', direction='output', size=None)</pre> <p>Most importantly, we don't know what is the total cost of the algorithm:</p> In\u00a0[11]: Copied! <pre>uncompiled_routine.resources\n</pre> uncompiled_routine.resources Out[11]: <pre>[]</pre> <p>So what we want to do, is to get to the following picture: </p> <p>You can compare it with the previous picture and see how \"local\" variables have been replaced with \"global\" ones.</p> <p>We do this with the following command:</p> In\u00a0[12]: Copied! <pre>from bartiq import compile_routine\ncompiled_routine = compile_routine(my_algorithm_qref).routine\n</pre> from bartiq import compile_routine compiled_routine = compile_routine(my_algorithm_qref).routine <p>Now let's check the same fields of our <code>compiled_routine</code> object:</p> In\u00a0[13]: Copied! <pre>print(\"T gates for A:\", compiled_routine.children[\"A\"].resources[\"T_gates\"].value)\nprint(\"Output size:\", compiled_routine.ports[\"out\"].size)\nprint(\"Total T gates:\", compiled_routine.resources[\"T_gates\"].value)\n</pre> print(\"T gates for A:\", compiled_routine.children[\"A\"].resources[\"T_gates\"].value) print(\"Output size:\", compiled_routine.ports[\"out\"].size) print(\"Total T gates:\", compiled_routine.resources[\"T_gates\"].value) <pre>T gates for A: 2*n + z\nOutput size: 2*n + z\nTotal T gates: 2*n*z*ceiling(log2(2*n)) + 2*n + z\n</pre> <p>Since the resources in the children have type <code>additive</code>, <code>bartiq</code> automatically added the <code>T_gates</code> resource to the parent as a sum of the resources of the children.</p> <p>Now it would be good to know what is the cost when we subsitute some numbers. We can do this using <code>evaluate</code> method. As you can see in the example below, it can either substitute all the parameters or just some of them.</p> In\u00a0[14]: Copied! <pre>from bartiq import evaluate\n\nprint(\"Different values of n:\")\nfor n in range(6, 16, 2):\n    assignments = {\"n\": n}\n    evaluated_routine = evaluate(compiled_routine, assignments).routine\n    print(f\"n = {n}, total T gates:\", evaluated_routine.resources[\"T_gates\"].value)\n\nz = 5\nassignments = {\"n\": n, \"z\": z}\nevaluated_routine = evaluate(compiled_routine, assignments).routine\nprint(f\"For n={n}, z={z}\")\n\nprint(\"Total T gates:\", evaluated_routine.resources[\"T_gates\"].value)\n</pre> from bartiq import evaluate  print(\"Different values of n:\") for n in range(6, 16, 2):     assignments = {\"n\": n}     evaluated_routine = evaluate(compiled_routine, assignments).routine     print(f\"n = {n}, total T gates:\", evaluated_routine.resources[\"T_gates\"].value)  z = 5 assignments = {\"n\": n, \"z\": z} evaluated_routine = evaluate(compiled_routine, assignments).routine print(f\"For n={n}, z={z}\")  print(\"Total T gates:\", evaluated_routine.resources[\"T_gates\"].value) <pre>Different values of n:\nn = 6, total T gates: 49*z + 12\nn = 8, total T gates: 65*z + 16\nn = 10, total T gates: 101*z + 20\nn = 12, total T gates: 121*z + 24\nn = 14, total T gates: 141*z + 28\nFor n=14, z=5\nTotal T gates: 733\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/01_basic_example/#basic-example","title":"Basic example\u00b6","text":""},{"location":"tutorials/01_basic_example/#compilation","title":"Compilation\u00b6","text":""},{"location":"tutorials/01_basic_example/#evaluation","title":"Evaluation\u00b6","text":""},{"location":"tutorials/01_basic_example/#summary","title":"Summary\u00b6","text":"<p>Let's sum up what we covered in this tutorial:</p> <ul> <li>How to construct a simple algorithm to use with <code>bartiq</code></li> <li>How to compile an estimate</li> <li>How to evaluate an estimate</li> <li>How to use the <code>qref</code> visualization tool to visualize an algorithm</li> </ul> <p>In the next tutorial we'll cover how to implement a more complex algorithm from a paper.</p>"},{"location":"tutorials/02_alias_sampling_basic/","title":"Alias Sampling","text":"<p>NOTE:</p> <p>This tutorial, as well as all the other tutorials, has been written as a jupyter notebook. If you're reading it online, you can either keep reading, or clone the repository and go to <code>docs/tutorials</code> to explore them in a more interactive way!</p> <p>The example we used in previous tutorial was nice to establish some basic terminology. But let's be honest, it was contrived and not very practical. So now we'll take an existing example from a paper and try to get some resource estimations for it using <code>bartiq</code>!</p> <p>For that we'll use Alias Sampling\u2014an algorithm proposed by Babbush et al. in Encoding Electronic Spectra in Quantum Circuits with Linear T Complexity\u00a0\u29c9. This is what the circuit looks like:</p> <p></p> <p>It comes from Fig. 11 from the original paper.</p> <p>This circuit is an important subroutine in the paper's larger algorithm because it is responsible for preparing arbitrary quantum states, which can be thought of as \"loading\" data into the quantum computer.</p> <p>In this tutorial we won't be explaining how the algorithm works in details\u2014partly because this is not the place, and partly because Craig Gidney already did it in his blogpost\u00a0\u29c9</p> <p>But briefly and at a high level, Alias Sampling contains the following subroutines:</p> <ul> <li>$\\textrm{UNIFORM}_L$:\u00a0prepares a state which is a uniform superposition over $L$ basis states</li> <li>$H^{\\otimes\\mu}$: applies a set of Hadamard gates to create a uniform superposition over $2^{\\mu}$ basis states</li> <li>QROM: loads data values into two \"data\" registers in superposition depending on the state input to $\\textrm{In}_{\\ell}$</li> <li>Comparator:\u00a0flips a target qubit if $\\textrm{keep}_l \\leq \\sigma_l$ based on the values of the two other input registers (to $\\textrm{In}_{\\sigma_l}$ and $\\textrm{In}_{\\textrm{keep}_l}$ respectively).</li> <li>Controlled SWAP: swaps two target registers conditional on the value of a control qubit.</li> </ul> <p>Now, before we map all these subroutines to <code>qref</code>, it would be good to know what the costs of each of the subroutines are. After carefully reading the paper we can deduce what the costs are. But before we get there, let's define our symbols to have consistent naming.  The authors use same letters for different variables in different figures, so it can get confusing without reading the paper carefully\u2014that's why we'll stick to the naming from the figure above to keep things simple.</p> <ul> <li>$L$ \u2013\u00a0number of coefficients we want to load.</li> <li>$\\mu$ \u2013 bits of precision for coefficients we load.</li> <li>$k$ is the exponent of 2 in the prime factorization of $L$. In other words, it is the largest integer such that  $2^k$ divides $L$. This is not a widely-used mathematical operation, but fortunately in <code>bartiq</code> we can use a shorthand for that, and we say that <code>k = multiplicity(2, L)</code>. For more information, you can check how it's defined in sympy\u00a0\u29c9.</li> </ul> <p>Given all that\u2014what are the costs of our routines? For the purpose of we shall focus on just calculating the T-gate and rotation costs:</p> <ul> <li>Uniform: $8(\\lceil\\log_2(L/2^k)\\rceil-1)$ T-gates and 2 rotation gates. It comes Fig 12 and its caption. We omit the $O(\\log(1/\\epsilon)$ term, because it corresponds to those two rotations that we count separately.</li> <li>Hadamards: No T-gates or rotations.</li> <li>QROM: $4L-4$ \u2013 this comes from Fig. 10.</li> <li>Comparator: $4\\mu-4$ \u2013\u00a0this is not stated explicitly in the text, but comes from a careful analysis of the caption of Fig. 11.</li> <li>Swap: $O(\\log_2(L))$ \u2013 this is not stated explicitly in the text, but comes from a careful analysis of the caption of Fig. 11.</li> </ul> <p>These expressions don't take into account some nuances\u2014for example the uniform state preparation (USP) can be implemented as a layer of Hadamard gates if $L$ is a power of two.</p> <p>Armed with this knowledge, we can now write each individual routine. However, since in this case all the routines have similar structure, we can use the following helper function:</p> <p>NOTE:</p> <p>Unfortunately the costs presented in this example are quite complicated. It would be great to just point you to a single place in the paper, get an expression and type it into <code>bartiq</code>. That's not the case though and if there are any mistakes or oversimplifications\u2014please let us know! However, the fact that even a relatively simple routine presents such challenges, shows that we need better tools for working with quantum algorithms.</p> <p>Also, as it turns out in the follow-up work not all the costs from this paper are correct, as some routines can be optimized. But explaining that is way beyond the scope of this tutorial.</p> In\u00a0[1]: Copied! <pre>usp_dict = {\n    \"name\": \"usp\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"in\", \"direction\": \"input\", \"size\": \"R\"},\n        {\"name\": \"out\", \"direction\": \"output\", \"size\": \"R\"},\n    ],\n    \"resources\": [\n        {\n            \"name\": \"T_gates\",\n            \"type\": \"additive\",\n            \"value\": \"8*(ceiling(log_2(L/(2 ** multiplicity(2,L))))-1)\",\n        },\n        {\"name\": \"rotations\", \"type\": \"additive\", \"value\": \"2\"},\n    ],\n    \"input_params\": [\"L\"],\n    \"local_variables\": {\"R\": \"ceiling(log_2(L))\"},\n}\n</pre> usp_dict = {     \"name\": \"usp\",     \"type\": None,     \"ports\": [         {\"name\": \"in\", \"direction\": \"input\", \"size\": \"R\"},         {\"name\": \"out\", \"direction\": \"output\", \"size\": \"R\"},     ],     \"resources\": [         {             \"name\": \"T_gates\",             \"type\": \"additive\",             \"value\": \"8*(ceiling(log_2(L/(2 ** multiplicity(2,L))))-1)\",         },         {\"name\": \"rotations\", \"type\": \"additive\", \"value\": \"2\"},     ],     \"input_params\": [\"L\"],     \"local_variables\": {\"R\": \"ceiling(log_2(L))\"}, } <p>There are two things that we did here which might not be straight-forward.</p> <ul> <li>We used <code>ceiling</code> function for the port size\u2014that's because port sizes need to be integer.</li> <li>We introduced new field: <code>local_variables</code>. This allows us to define some \"helper\" variables, which are only used in the scope of this routine and save us some typing</li> </ul> In\u00a0[2]: Copied! <pre>had_dict = {\n    \"name\": \"had\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"in\", \"direction\": \"input\", \"size\": \"N\"},\n        {\"name\": \"out\", \"direction\": \"output\", \"size\": \"N\"},\n    ],\n}\n</pre> had_dict = {     \"name\": \"had\",     \"type\": None,     \"ports\": [         {\"name\": \"in\", \"direction\": \"input\", \"size\": \"N\"},         {\"name\": \"out\", \"direction\": \"output\", \"size\": \"N\"},     ], } In\u00a0[3]: Copied! <pre>qrom_dict = {\n    \"name\": \"qrom\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"In_l\", \"direction\": \"input\", \"size\": \"R\"},\n        {\"name\": \"In_alt\", \"direction\": \"input\", \"size\": \"R\"},\n        {\"name\": \"In_keep\", \"direction\": \"input\", \"size\": \"mu\"},\n        {\"name\": \"out_l\", \"direction\": \"output\", \"size\": \"R\"},\n        {\"name\": \"out_alt\", \"direction\": \"output\", \"size\": \"R\"},\n        {\"name\": \"out_keep\", \"direction\": \"output\", \"size\": \"mu\"},\n    ],\n    \"resources\": [{\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"4*L-4\"}],\n    \"input_params\": [\"L\", \"mu\"],\n    \"local_variables\": {\"R\": \"ceiling(log_2(L))\"},\n}\n</pre> qrom_dict = {     \"name\": \"qrom\",     \"type\": None,     \"ports\": [         {\"name\": \"In_l\", \"direction\": \"input\", \"size\": \"R\"},         {\"name\": \"In_alt\", \"direction\": \"input\", \"size\": \"R\"},         {\"name\": \"In_keep\", \"direction\": \"input\", \"size\": \"mu\"},         {\"name\": \"out_l\", \"direction\": \"output\", \"size\": \"R\"},         {\"name\": \"out_alt\", \"direction\": \"output\", \"size\": \"R\"},         {\"name\": \"out_keep\", \"direction\": \"output\", \"size\": \"mu\"},     ],     \"resources\": [{\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"4*L-4\"}],     \"input_params\": [\"L\", \"mu\"],     \"local_variables\": {\"R\": \"ceiling(log_2(L))\"}, } In\u00a0[4]: Copied! <pre>compare_dict = {\n    \"name\": \"compare\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"In_sigma\", \"direction\": \"input\", \"size\": \"mu\"},\n        {\"name\": \"In_keep\", \"direction\": \"input\", \"size\": \"mu\"},\n        {\"name\": \"In_flag\", \"direction\": \"input\", \"size\": \"1\"},\n        {\"name\": \"out_sigma\", \"direction\": \"output\", \"size\": \"mu\"},\n        {\"name\": \"out_keep\", \"direction\": \"output\", \"size\": \"mu\"},\n        {\"name\": \"out_flag\", \"direction\": \"output\", \"size\": \"1\"},\n    ],\n    \"resources\": [{\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"4*mu-4\"}],\n    \"input_params\": [\"mu\"],\n}\n</pre> compare_dict = {     \"name\": \"compare\",     \"type\": None,     \"ports\": [         {\"name\": \"In_sigma\", \"direction\": \"input\", \"size\": \"mu\"},         {\"name\": \"In_keep\", \"direction\": \"input\", \"size\": \"mu\"},         {\"name\": \"In_flag\", \"direction\": \"input\", \"size\": \"1\"},         {\"name\": \"out_sigma\", \"direction\": \"output\", \"size\": \"mu\"},         {\"name\": \"out_keep\", \"direction\": \"output\", \"size\": \"mu\"},         {\"name\": \"out_flag\", \"direction\": \"output\", \"size\": \"1\"},     ],     \"resources\": [{\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"4*mu-4\"}],     \"input_params\": [\"mu\"], } In\u00a0[5]: Copied! <pre>swap_dict = {\n    \"name\": \"swap\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"In_control\", \"direction\": \"input\", \"size\": \"1\"},\n        {\"name\": \"In_target_0\", \"direction\": \"input\", \"size\": \"X\"},\n        {\"name\": \"In_target_1\", \"direction\": \"input\", \"size\": \"X\"},\n        {\"name\": \"out_control\", \"direction\": \"output\", \"size\": None},\n        {\"name\": \"out_target_0\", \"direction\": \"output\", \"size\": None},\n        {\"name\": \"out_target_1\", \"direction\": \"output\", \"size\": None},\n    ],\n    \"resources\": [{\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"O(log_2(X))\"}],\n    \"connections\": [\n        {\"source\": \"In_control\", \"target\": \"out_control\"},\n        {\"source\": \"In_target_0\", \"target\": \"out_target_0\"},\n        {\"source\": \"In_target_1\", \"target\": \"out_target_1\"},\n    ],\n    \"input_params\": [\"X\"],\n}\n</pre> swap_dict = {     \"name\": \"swap\",     \"type\": None,     \"ports\": [         {\"name\": \"In_control\", \"direction\": \"input\", \"size\": \"1\"},         {\"name\": \"In_target_0\", \"direction\": \"input\", \"size\": \"X\"},         {\"name\": \"In_target_1\", \"direction\": \"input\", \"size\": \"X\"},         {\"name\": \"out_control\", \"direction\": \"output\", \"size\": None},         {\"name\": \"out_target_0\", \"direction\": \"output\", \"size\": None},         {\"name\": \"out_target_1\", \"direction\": \"output\", \"size\": None},     ],     \"resources\": [{\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"O(log_2(X))\"}],     \"connections\": [         {\"source\": \"In_control\", \"target\": \"out_control\"},         {\"source\": \"In_target_0\", \"target\": \"out_target_0\"},         {\"source\": \"In_target_1\", \"target\": \"out_target_1\"},     ],     \"input_params\": [\"X\"], } <p>We follow the same naming convention in all the subroutines to make things easier to follow. But in swap, we decided to use <code>X</code> instead of <code>R=ceiling(log_2(L))</code>. Why?</p> <p>It shows, that we can use whatever naming we want for any particular subroutine \u2013 we don't need to stick to one convention in all the subroutines. This is what you would often want to do in practice. If you would like to reuse this controlled swap in some other algorithm, a generic <code>X</code> is a much better choice than a very specific <code>R</code>.</p> <p>Now that we have all these defined, let's construct the dictionary for the whole algorithm:</p> In\u00a0[6]: Copied! <pre>alias_sampling_dict = {\n    \"name\": \"alias_sampling\",\n    \"children\": [usp_dict, had_dict, qrom_dict, compare_dict, swap_dict],\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"In_0\", \"direction\": \"input\", \"size\": \"R\"},\n        {\"name\": \"In_1\", \"direction\": \"input\", \"size\": \"mu\"},\n        {\"name\": \"In_2\", \"direction\": \"input\", \"size\": \"R\"},\n        {\"name\": \"In_3\", \"direction\": \"input\", \"size\": \"mu\"},\n        {\"name\": \"In_4\", \"direction\": \"input\", \"size\": \"1\"},\n        {\"name\": \"out_0\", \"direction\": \"output\", \"size\": None},\n        {\"name\": \"temp_0\", \"direction\": \"output\", \"size\": None},\n        {\"name\": \"temp_1\", \"direction\": \"output\", \"size\": None},\n        {\"name\": \"temp_2\", \"direction\": \"output\", \"size\": None},\n        {\"name\": \"temp_3\", \"direction\": \"output\", \"size\": None},\n    ],\n    \"connections\": [\n        {\"source\": \"In_0\", \"target\": \"usp.in\"},\n        {\"source\": \"In_1\", \"target\": \"had.in\"},\n        {\"source\": \"In_2\", \"target\": \"qrom.In_alt\"},\n        {\"source\": \"In_3\", \"target\": \"qrom.In_keep\"},\n        {\"source\": \"In_4\", \"target\": \"compare.In_flag\"},\n        {\"source\": \"usp.out\", \"target\": \"qrom.In_l\"},\n        {\"source\": \"had.out\", \"target\": \"compare.In_sigma\"},\n        {\"source\": \"qrom.out_l\", \"target\": \"swap.In_target_0\"},\n        {\"source\": \"qrom.out_alt\", \"target\": \"swap.In_target_1\"},\n        {\"source\": \"qrom.out_keep\", \"target\": \"compare.In_keep\"},\n        {\"source\": \"compare.out_flag\", \"target\": \"swap.In_control\"},\n        {\"source\": \"swap.out_target_0\", \"target\": \"out_0\"},\n        {\"source\": \"compare.out_sigma\", \"target\": \"temp_0\"},\n        {\"source\": \"swap.out_target_1\", \"target\": \"temp_1\"},\n        {\"source\": \"compare.out_keep\", \"target\": \"temp_2\"},\n        {\"source\": \"swap.out_control\", \"target\": \"temp_3\"},\n    ],\n    \"input_params\": [\"mu\", \"L\"],\n    \"local_variables\": {\"R\": \"ceiling(log_2(L))\"},\n    \"linked_params\": [\n        {\"source\": \"L\", \"targets\": [\"usp.L\", \"qrom.L\", \"swap.X\"]},\n        {\"source\": \"mu\", \"targets\": [\"qrom.mu\", \"compare.mu\"]},\n    ],\n}\n</pre> alias_sampling_dict = {     \"name\": \"alias_sampling\",     \"children\": [usp_dict, had_dict, qrom_dict, compare_dict, swap_dict],     \"type\": None,     \"ports\": [         {\"name\": \"In_0\", \"direction\": \"input\", \"size\": \"R\"},         {\"name\": \"In_1\", \"direction\": \"input\", \"size\": \"mu\"},         {\"name\": \"In_2\", \"direction\": \"input\", \"size\": \"R\"},         {\"name\": \"In_3\", \"direction\": \"input\", \"size\": \"mu\"},         {\"name\": \"In_4\", \"direction\": \"input\", \"size\": \"1\"},         {\"name\": \"out_0\", \"direction\": \"output\", \"size\": None},         {\"name\": \"temp_0\", \"direction\": \"output\", \"size\": None},         {\"name\": \"temp_1\", \"direction\": \"output\", \"size\": None},         {\"name\": \"temp_2\", \"direction\": \"output\", \"size\": None},         {\"name\": \"temp_3\", \"direction\": \"output\", \"size\": None},     ],     \"connections\": [         {\"source\": \"In_0\", \"target\": \"usp.in\"},         {\"source\": \"In_1\", \"target\": \"had.in\"},         {\"source\": \"In_2\", \"target\": \"qrom.In_alt\"},         {\"source\": \"In_3\", \"target\": \"qrom.In_keep\"},         {\"source\": \"In_4\", \"target\": \"compare.In_flag\"},         {\"source\": \"usp.out\", \"target\": \"qrom.In_l\"},         {\"source\": \"had.out\", \"target\": \"compare.In_sigma\"},         {\"source\": \"qrom.out_l\", \"target\": \"swap.In_target_0\"},         {\"source\": \"qrom.out_alt\", \"target\": \"swap.In_target_1\"},         {\"source\": \"qrom.out_keep\", \"target\": \"compare.In_keep\"},         {\"source\": \"compare.out_flag\", \"target\": \"swap.In_control\"},         {\"source\": \"swap.out_target_0\", \"target\": \"out_0\"},         {\"source\": \"compare.out_sigma\", \"target\": \"temp_0\"},         {\"source\": \"swap.out_target_1\", \"target\": \"temp_1\"},         {\"source\": \"compare.out_keep\", \"target\": \"temp_2\"},         {\"source\": \"swap.out_control\", \"target\": \"temp_3\"},     ],     \"input_params\": [\"mu\", \"L\"],     \"local_variables\": {\"R\": \"ceiling(log_2(L))\"},     \"linked_params\": [         {\"source\": \"L\", \"targets\": [\"usp.L\", \"qrom.L\", \"swap.X\"]},         {\"source\": \"mu\", \"targets\": [\"qrom.mu\", \"compare.mu\"]},     ], } In\u00a0[7]: Copied! <pre>from qref import SchemaV1\nalias_sampling_qref = {\"version\": \"v1\", \"program\": alias_sampling_dict}\nuncompiled_routine = SchemaV1(**alias_sampling_qref)\n</pre> from qref import SchemaV1 alias_sampling_qref = {\"version\": \"v1\", \"program\": alias_sampling_dict} uncompiled_routine = SchemaV1(**alias_sampling_qref) <p>Additionally, you can examine how the circuit is represented in <code>qref</code> format by visualizing it.</p> <p>NOTE:</p> <p>         To use the qref\u00a0\u29c9 rendering tool in Jupyter Notebook, ensure the Graphviz software is installed on your OS and that its executables are included in your system variables. For installation instructions, please refer to the Graphviz download page\u00a0\u29c9.     </p> <p>Once installed, proceed to visualize the representation of the circuit.</p> In\u00a0[8]: Copied! <pre>from qref.experimental.rendering import to_graphviz\n\n# Convert the qref format to Graphviz object\ngv_object = to_graphviz(uncompiled_routine)\n\n# Render the Graphviz object to a PNG file\ngv_object.render(\"alias_sampling\", format=\"png\")\ngv_object\n</pre> from qref.experimental.rendering import to_graphviz  # Convert the qref format to Graphviz object gv_object = to_graphviz(uncompiled_routine)  # Render the Graphviz object to a PNG file gv_object.render(\"alias_sampling\", format=\"png\") gv_object Out[8]: <p>As we expected, the diagram displays five subroutines which are <code>usp</code>, <code>qrom</code>, <code>compare</code>, <code>had</code>, <code>swap</code>, and their hierarchical connections. Everything appears to be in order! Let's proceed with the compilation.</p> In\u00a0[9]: Copied! <pre>from bartiq import compile_routine\n\ncompiled_routine = compile_routine(uncompiled_routine).routine\n</pre> from bartiq import compile_routine  compiled_routine = compile_routine(uncompiled_routine).routine <p>It went pretty well, let's see what's the we got:</p> In\u00a0[10]: Copied! <pre>for resource in compiled_routine.resources.values():\n    print(f\"{resource.name}: {resource.value}\")\n</pre> for resource in compiled_routine.resources.values():     print(f\"{resource.name}: {resource.value}\") <pre>T_gates: 4*L + 4*mu + O(log2(L)) + 8*ceiling(log2(L/2**multiplicity(2, L))) - 16\nrotations: 2\n</pre> <p>In the caption of Fig. 11 we had: $4(L + \\mu) + O(\\log_2(L))$, and these two expressions actually match pretty well.</p> <ul> <li>We have the $4(L + \\mu)$ as well as $O(log_2(L))$ in both versions.</li> <li>The <code>8*ceiling(log2(L/2 ^ multiplicity(2, L)))</code> term is also $O(log_2(L))$ in disguise.</li> <li>Constant factor of <code>-16</code> can also be incorporated in <code>O(log_2(L))</code></li> </ul> <p>Let's see how it looks like for some concrete values:</p> In\u00a0[11]: Copied! <pre>from bartiq import evaluate\n\nassignments = {\"L\":120, \"mu\":8}\nevaluated_routine = evaluate(compiled_routine, assignments).routine\nfor resource in evaluated_routine.resources.values():\n    print(f\"{resource.name}: {resource.value}\")\n</pre> from bartiq import evaluate  assignments = {\"L\":120, \"mu\":8} evaluated_routine = evaluate(compiled_routine, assignments).routine for resource in evaluated_routine.resources.values():     print(f\"{resource.name}: {resource.value}\") <pre>T_gates: O(log2(120)) + 528\nrotations: 2\n</pre> <p>We still have big O there, so we can't get a concrete number. So let's assume a simple case, i.e. <code>O(x) = ceiling(x)</code>. We'll provide information how to evaluate it in <code>bartiq</code> using <code>functions_map</code> argument.</p> In\u00a0[12]: Copied! <pre>import math\n\ndef big_O(x):\n    return math.ceil(x)\n\nfunctions_map = {\"O\": big_O}\nevaluation_result = evaluate(compiled_routine, assignments, functions_map=functions_map)\nqref_routine = evaluation_result.to_qref()\nfor resource in evaluation_result.routine.resources.values():\n    print(f\"{resource.name}: {resource.value}\")\n</pre> import math  def big_O(x):     return math.ceil(x)  functions_map = {\"O\": big_O} evaluation_result = evaluate(compiled_routine, assignments, functions_map=functions_map) qref_routine = evaluation_result.to_qref() for resource in evaluation_result.routine.resources.values():     print(f\"{resource.name}: {resource.value}\") <pre>T_gates: 535\nrotations: 2\n</pre> <p>And now we finally have some concrete numbers!</p> In\u00a0[13]: Copied! <pre>from bartiq.integrations import explore_routine\n\nexplore_routine(qref_routine)\n</pre> from bartiq.integrations import explore_routine  explore_routine(qref_routine) Out[13]: <pre>HBox(children=(_RoutineTree(multiple_selection=False, nodes=(Node(name='alias_sampling', nodes=(Node(name='com\u2026</pre> <p>If you'd prefer a static representation, you can also simply export routine to latex, though it only shows information about the top-level routine:</p> In\u00a0[14]: Copied! <pre>from bartiq.integrations import routine_to_latex\nfrom IPython.display import Math\n\nMath(routine_to_latex(qref_routine))\n</pre> from bartiq.integrations import routine_to_latex from IPython.display import Math  Math(routine_to_latex(qref_routine)) Out[14]:  $\\displaystyle \\begin{align} &amp;\\text{RoutineV1 \\textrm{(alias\\_sampling)}}\\newline &amp;\\underline{\\text{Input ports:}}\\\\ &amp;\\text{In\\_0} = 7\\\\ &amp;\\text{In\\_1} = 8\\\\ &amp;\\text{In\\_2} = 7\\\\ &amp;\\text{In\\_3} = 8\\\\ &amp;\\text{In\\_4} = 1\\newline &amp;\\underline{\\text{Output ports:}}\\\\ &amp;\\text{out\\_0} = 7\\\\ &amp;\\text{temp\\_0} = 8\\\\ &amp;\\text{temp\\_1} = 7\\\\ &amp;\\text{temp\\_2} = 8\\\\ &amp;\\text{temp\\_3} = 1\\newline &amp;\\underline{\\text{Resources:}}\\\\ &amp;T_{\\text{gates}} = 535\\\\ &amp;rotations = 2\\\\ &amp;\\text{compare}.\\!T_{\\text{gates}} = 28\\\\ &amp;\\text{qrom}.\\!T_{\\text{gates}} = 476\\\\ &amp;\\text{swap}.\\!T_{\\text{gates}} = 7\\\\ &amp;\\text{usp}.\\!T_{\\text{gates}} = 24\\\\ &amp;\\text{usp}.\\!rotations = 2 \\end{align}$  In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/02_alias_sampling_basic/#alias-sampling","title":"Alias Sampling\u00b6","text":""},{"location":"tutorials/02_alias_sampling_basic/#exploring-the-estimates","title":"Exploring the estimates\u00b6","text":"<p>If we just interact with bare python objects, getting a quick idea of the values of various fields might be a bit cumbersome. That's where <code>explore_routine</code> functions might be helpful. Try it out using the snippet below.</p> <p>NOTE:</p> This is an interactive feature and will not render in the static version of the docs. To use it you need to run this tutorial as a jupyter notebook.  Remember to install bartiq with <code>pip install bartiq[jupyter]</code> to make sure you have all the dependencies needed for these widgets to work (for more details visit installation docs\u00a0\u29c9)."},{"location":"tutorials/02_alias_sampling_basic/#summary","title":"Summary\u00b6","text":"<p>Let's sum up what we covered in this tutorial:</p> <ul> <li>How to take an algorithm from a paper and compile it into <code>bartiq</code></li> <li>How to create a routine with multiple resources, <code>local_variables</code> and custom functions</li> <li>How to use <code>explore_routine</code> and latex integration to get most out of <code>bartiq</code></li> </ul>"},{"location":"tutorials/03_advanced_examples/","title":"Using bartiq for Resource Analysis","text":"<p>NOTE:</p> <p>This tutorial, as well as all the other tutorials, has been written as a jupyter notebook. If you're reading it online, you can either keep reading, or clone the repository and go to <code>docs/tutorials</code> to explore them in a more interactive way!</p> <p>It is time to explore how to use <code>bartiq</code>'s resource estimation capabilities in practical quantum algorithm analysis. In this tutorial, you will:</p> <ul> <li>Compare resources of different implementations of the same operation/unitary using <code>bartiq</code>.</li> <li>Transform your estimate to obtain more useful information about the problem.</li> <li>Learn how to implement nested hierarchy in <code>bartiq</code>.</li> </ul> <p>In the previous tutorial\u00a0\u29c9, we demonstrated how the alias sampling algorithm works, along with its subroutines - USP, $H^{\\otimes\\mu}$, QROM, comparator, and controlled SWAP. Beyond the uniform state preparation (USP) method introduced in tutorial 02, several other USP implementations are worth considering as alternatives. You can think of these implementations as interchangeable quantum circuits\u3002</p> <p>In this tutorial we will see if we can make alias sampling use less resources by using a different implementation of USP.</p> <p>NOTE:</p> <p>This tutorial is not meant to provide definitive expressions. Instead, it is designed to guide you through relevant sections of the papers, obtain expressions and use them to demonstrate how <code>bartiq</code> works. If you find any mistakes or oversimplifications, please let us know!</p> <p>Additionally, future work may reveal that not all cost estimates are accurate, as some routines can be optimized further. However, explaining these optimizations is beyond the scope of this tutorial.</p> <p>The implementation of the <code>USP</code> method in Encoding Electronic Spectra...\u00a0\u29c9 has been described in tutorial 02\u00a0\u29c9. Let's do a quick recap.</p> <p>Here, we will break down the <code>USP</code> routine into more detailed operations, including the inequality test, rotation, (uncompute) inequality test, and a (controlled) rotation. Since these operations are not run in parallel nor share qubits at the same time, representing each individual subroutine is straightforward and intuitive. Below is the circuit diagram for the USP, adapted from Figure 12 of the original paper:</p> <p></p> In\u00a0[1]: Copied! <pre>def generate_inequality_test(name):\n    return {\n        \"name\": name,\n        \"type\": None,\n        \"ports\": [\n            {\"name\": \"in\", \"direction\": \"input\", \"size\": \"R\"},\n            {\"name\": \"out\", \"direction\": \"output\", \"size\": \"R\"},\n        ],\n        \"resources\": [\n            {\n                \"name\": \"T_gates\",\n                \"type\": \"additive\",\n                \"value\": \"4*ceiling(log_2(L/(2 ** k))-1)\",\n            },\n        ],\n        \"input_params\": [\"L\"],\n        \"local_variables\": {\"R\": \"ceiling(log_2(L))\", \"k\": \"multiplicity(2,L)\"},\n    }\n</pre> def generate_inequality_test(name):     return {         \"name\": name,         \"type\": None,         \"ports\": [             {\"name\": \"in\", \"direction\": \"input\", \"size\": \"R\"},             {\"name\": \"out\", \"direction\": \"output\", \"size\": \"R\"},         ],         \"resources\": [             {                 \"name\": \"T_gates\",                 \"type\": \"additive\",                 \"value\": \"4*ceiling(log_2(L/(2 ** k))-1)\",             },         ],         \"input_params\": [\"L\"],         \"local_variables\": {\"R\": \"ceiling(log_2(L))\", \"k\": \"multiplicity(2,L)\"},     } In\u00a0[2]: Copied! <pre>def generate_rotation(name):\n    return {\n        \"name\": name,\n        \"type\": None,\n        \"ports\": [\n            {\"name\": \"in\", \"direction\": \"input\", \"size\": \"R\"},\n            {\"name\": \"out\", \"direction\": \"output\", \"size\": \"R\"},\n        ],\n        \"resources\": [\n            {\"name\": \"rz\", \"type\": \"additive\", \"value\": \"1\"},\n        ],\n        \"input_params\": [\"L\"],\n        \"local_variables\": {\"R\": \"ceiling(log_2(L))\"},\n    }\n</pre> def generate_rotation(name):     return {         \"name\": name,         \"type\": None,         \"ports\": [             {\"name\": \"in\", \"direction\": \"input\", \"size\": \"R\"},             {\"name\": \"out\", \"direction\": \"output\", \"size\": \"R\"},         ],         \"resources\": [             {\"name\": \"rz\", \"type\": \"additive\", \"value\": \"1\"},         ],         \"input_params\": [\"L\"],         \"local_variables\": {\"R\": \"ceiling(log_2(L))\"},     } In\u00a0[3]: Copied! <pre>def generate_controlled_rotation(name):\n    return {\n        \"name\": name,\n        \"type\": None,\n        \"ports\": [\n            {\"name\": \"in\", \"direction\": \"input\", \"size\": \"R\"},\n            {\"name\": \"out\", \"direction\": \"output\", \"size\": \"R\"},\n        ],\n        \"resources\": [\n            {\"name\": \"rz\", \"type\": \"additive\", \"value\": \"1\"},\n            # (log_2(L/(2 ** k))-2) Toffoli gates\n            {\n                \"name\": \"T_gates\",\n                \"type\": \"additive\",\n                \"value\": \"4*ceiling(log_2(L/(2 ** k))-2)\",\n            },\n        ],\n        \"input_params\": [\"L\"],\n        \"local_variables\": {\"R\": \"ceiling(log_2(L))\", \"k\": \"multiplicity(2,L)\"},\n    }\n</pre> def generate_controlled_rotation(name):     return {         \"name\": name,         \"type\": None,         \"ports\": [             {\"name\": \"in\", \"direction\": \"input\", \"size\": \"R\"},             {\"name\": \"out\", \"direction\": \"output\", \"size\": \"R\"},         ],         \"resources\": [             {\"name\": \"rz\", \"type\": \"additive\", \"value\": \"1\"},             # (log_2(L/(2 ** k))-2) Toffoli gates             {                 \"name\": \"T_gates\",                 \"type\": \"additive\",                 \"value\": \"4*ceiling(log_2(L/(2 ** k))-2)\",             },         ],         \"input_params\": [\"L\"],         \"local_variables\": {\"R\": \"ceiling(log_2(L))\", \"k\": \"multiplicity(2,L)\"},     } <p>The dictionary for the entire algorithm is shown below. You might notice that, compared to the previous tutorial, we have introduced ancilla qubits as a new resource here. Yes, ancilla qubits can be considered a resource just like quantum gates. We include ancilla qubits in the overall USP routine, rather than in the subroutines, because the two inequality tests operate on the same set of ancillas. Additionally, we're considering reallocating the ancillas for the subsequent controlled rotation. We use type <code>qubits</code> for them, though at the moment Bartiq does not handle this type in any special way.</p> <p>Also, please note that these are arbitrary choices \u2013  you might want to experiment a bit to see which setup works best in your case.</p> In\u00a0[4]: Copied! <pre>usp_dict = {\n    \"name\": \"usp\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"in\", \"direction\": \"input\", \"size\": \"R\"},\n        {\"name\": \"out\", \"direction\": \"output\", \"size\": \"R\"},\n    ],\n    \"children\": [\n        generate_inequality_test(\"inequality_test_1\"),\n        generate_rotation(\"rotation\"),\n        generate_inequality_test(\"inequality_test_2\"),\n        generate_controlled_rotation(\"controlled_rotation\"),\n    ],\n    \"input_params\": [\"L\"],\n    \"local_variables\": {\"R\": \"ceiling(log_2(L))\", \"k\": \"multiplicity(2,L)\"},\n    \"connections\": [\n        {\"source\": \"in\", \"target\": \"inequality_test_1.in\"},\n        {\"source\": \"inequality_test_1.out\", \"target\": \"rotation.in\"},\n        {\"source\": \"rotation.out\", \"target\": \"inequality_test_2.in\"},\n        {\"source\": \"inequality_test_2.out\", \"target\": \"controlled_rotation.in\"},\n        {\"source\": \"controlled_rotation.out\", \"target\": \"out\"},\n    ],\n    \"resources\": [\n        {\n            \"name\": \"ancilla\",\n            \"type\": \"qubits\",\n            \"value\": \"floor(log_2(L/2 ** k))\",\n        },\n    ],\n    \"linked_params\": [\n        {\n            \"source\": \"L\",\n            \"targets\": [\"inequality_test_1.L\", \"rotation.L\", \"inequality_test_2.L\", \"controlled_rotation.L\"],\n        },\n    ],\n}\n</pre> usp_dict = {     \"name\": \"usp\",     \"type\": None,     \"ports\": [         {\"name\": \"in\", \"direction\": \"input\", \"size\": \"R\"},         {\"name\": \"out\", \"direction\": \"output\", \"size\": \"R\"},     ],     \"children\": [         generate_inequality_test(\"inequality_test_1\"),         generate_rotation(\"rotation\"),         generate_inequality_test(\"inequality_test_2\"),         generate_controlled_rotation(\"controlled_rotation\"),     ],     \"input_params\": [\"L\"],     \"local_variables\": {\"R\": \"ceiling(log_2(L))\", \"k\": \"multiplicity(2,L)\"},     \"connections\": [         {\"source\": \"in\", \"target\": \"inequality_test_1.in\"},         {\"source\": \"inequality_test_1.out\", \"target\": \"rotation.in\"},         {\"source\": \"rotation.out\", \"target\": \"inequality_test_2.in\"},         {\"source\": \"inequality_test_2.out\", \"target\": \"controlled_rotation.in\"},         {\"source\": \"controlled_rotation.out\", \"target\": \"out\"},     ],     \"resources\": [         {             \"name\": \"ancilla\",             \"type\": \"qubits\",             \"value\": \"floor(log_2(L/2 ** k))\",         },     ],     \"linked_params\": [         {             \"source\": \"L\",             \"targets\": [\"inequality_test_1.L\", \"rotation.L\", \"inequality_test_2.L\", \"controlled_rotation.L\"],         },     ], } In\u00a0[5]: Copied! <pre>from qref import SchemaV1\nuncompiled_usp = SchemaV1(version=\"v1\", program=usp_dict)\n</pre> from qref import SchemaV1 uncompiled_usp = SchemaV1(version=\"v1\", program=usp_dict) <p>NOTE:</p> <p>         To use the qref\u00a0\u29c9 rendering tool in Jupyter Notebook, ensure the Graphviz software is installed on your OS and that its executables are included in your system variables. For installation instructions, please refer to the Graphviz download page\u00a0\u29c9.     </p> In\u00a0[6]: Copied! <pre>from qref.experimental.rendering import to_graphviz\n\n# Convert the qref format to Graphviz object\ngv_object = to_graphviz(uncompiled_usp)\n\n# Render the Graphviz object to a PNG file\ngv_object.render(\"usp\", format=\"png\")\ngv_object\n</pre> from qref.experimental.rendering import to_graphviz  # Convert the qref format to Graphviz object gv_object = to_graphviz(uncompiled_usp)  # Render the Graphviz object to a PNG file gv_object.render(\"usp\", format=\"png\") gv_object Out[6]: <p>and if we use this usp_dict to replace the usp in previous tutorial\u00a0\u29c9's alias sampling example, we'll have the alias sampling with more detailed hierarchy, like this:</p> In\u00a0[7]: Copied! <pre>import json\n\n# Load the alias sampling file\nwith open(\"../data/alias_sampling_basic.json\", \"r\") as f:\n    as_data = json.load(f)\n</pre> import json  # Load the alias sampling file with open(\"../data/alias_sampling_basic.json\", \"r\") as f:     as_data = json.load(f) In\u00a0[8]: Copied! <pre>as_qref = as_data.copy()\nfor i, child in enumerate(as_qref[\"program\"][\"children\"]):\n    if child[\"name\"] == \"usp\":\n        as_qref[\"program\"][\"children\"][i] = usp_dict\n\n# Convert the qref format to Graphviz object\ngv_object = to_graphviz(as_qref)\n\n# Render the Graphviz object to a PNG file\ngv_object.render(\"alias_nested\", format=\"png\")\ngv_object\n</pre> as_qref = as_data.copy() for i, child in enumerate(as_qref[\"program\"][\"children\"]):     if child[\"name\"] == \"usp\":         as_qref[\"program\"][\"children\"][i] = usp_dict  # Convert the qref format to Graphviz object gv_object = to_graphviz(as_qref)  # Render the Graphviz object to a PNG file gv_object.render(\"alias_nested\", format=\"png\") gv_object Out[8]: <p>Anyway, let's come back to the compilation process of <code>USP</code> in <code>bartiq</code>.</p> In\u00a0[9]: Copied! <pre>from bartiq import compile_routine\n\ncompiled_usp = compile_routine(uncompiled_usp).routine\nfor resource in compiled_usp.resources.values():\n    print(f\"{resource.name}: {resource.value}\")\n</pre> from bartiq import compile_routine  compiled_usp = compile_routine(uncompiled_usp).routine for resource in compiled_usp.resources.values():     print(f\"{resource.name}: {resource.value}\") <pre>ancilla: floor(log2(L/2**multiplicity(2, L)))\nT_gates: 12*ceiling(log2(L/2**multiplicity(2, L))) - 16\nrz: 2\n</pre> <p>In the definition of rotation, we used <code>rz</code> as the resource.</p> <p>Here, we can use <code>add_aggregated_resources</code> function to decompose the <code>rz</code> gates into more fundamental, general non-Clifford gates. This function takes a dictionary that specifies how to decompose the gates and a bartiq routine as parameters. It synthesizes all matching resources within the bartiq routine according to the dictionary.</p> <p>In this context, we approximate $R_z(\\theta)$ gates using an approximation of 50 T gates base on the approximation from Efficient Clifford+T approximation of single-qubit operators\u00a0\u29c9 with error threshold $\\epsilon = 0.001$. The exact number will depend on the desired accuracy of the approximation, but 50 T gates will be a good choice for many applications.</p> In\u00a0[10]: Copied! <pre>from bartiq.transform import add_aggregated_resources\n\naggregation_dict = {\"rz\": {\"T_gates\": 50}}\naggregated_usp = add_aggregated_resources(compiled_usp, aggregation_dict)\n# Note that aggregation removed the `rz` resources:\nprint(aggregated_usp.children[\"rotation\"].resources)\n</pre> from bartiq.transform import add_aggregated_resources  aggregation_dict = {\"rz\": {\"T_gates\": 50}} aggregated_usp = add_aggregated_resources(compiled_usp, aggregation_dict) # Note that aggregation removed the `rz` resources: print(aggregated_usp.children[\"rotation\"].resources) <pre>{'T_gates': Resource(name='T_gates', type=&lt;ResourceType.additive: 'additive'&gt;, value=50)}\n</pre> <p>Here is the final result of our resource estimation for the <code>USP</code> routine, contains only T gates and ancilla qubits:</p> In\u00a0[11]: Copied! <pre>for resource in aggregated_usp.resources.values():\n    print(f\"{resource.name}: {resource.value}\")\n</pre> for resource in aggregated_usp.resources.values():     print(f\"{resource.name}: {resource.value}\") <pre>ancilla: floor(log2(L/2**multiplicity(2, L)))\nT_gates: 12*ceiling(log2(L/2**multiplicity(2, L))) + 84\n</pre> In\u00a0[12]: Copied! <pre>from bartiq import evaluate\n\nvalues = [3, 5, 6, 7, 9, 10, 12, 14, 15]\nassignments_list = [{\"L\": value} for value in values]\n\nfor assignments in assignments_list:\n    evaluated_usp = evaluate(aggregated_usp, assignments).routine\n    print(f\"Assignment: {assignments}\")\n    for resource in evaluated_usp.resources.values():\n        print(f\"  {resource.name}: {resource.value}\")\n</pre> from bartiq import evaluate  values = [3, 5, 6, 7, 9, 10, 12, 14, 15] assignments_list = [{\"L\": value} for value in values]  for assignments in assignments_list:     evaluated_usp = evaluate(aggregated_usp, assignments).routine     print(f\"Assignment: {assignments}\")     for resource in evaluated_usp.resources.values():         print(f\"  {resource.name}: {resource.value}\") <pre>Assignment: {'L': 3}\n  ancilla: 1\n  T_gates: 108\nAssignment: {'L': 5}\n  ancilla: 2\n  T_gates: 120\nAssignment: {'L': 6}\n  ancilla: 1\n  T_gates: 108\nAssignment: {'L': 7}\n  ancilla: 2\n  T_gates: 120\nAssignment: {'L': 9}\n  ancilla: 3\n  T_gates: 132\nAssignment: {'L': 10}\n  ancilla: 2\n  T_gates: 120\nAssignment: {'L': 12}\n  ancilla: 1\n  T_gates: 108\nAssignment: {'L': 14}\n  ancilla: 2\n  T_gates: 120\nAssignment: {'L': 15}\n  ancilla: 3\n  T_gates: 132\n</pre> <p>An efficient quantum algorithm for preparation of uniform quantum superposition states\u00a0\u29c9  provides an alternative approach to USP that eliminates the need for ancilla qubits while maintaining similar asymptotic scaling to the other approach. We will refer to this as the <code>ZeroAncillaUSP</code>. The gate count for this method is detailed in Section 2.5 of the paper. Here, we will focus on the non-Clifford gate overhead and ignore the Clifford costs.</p> <p>To create a uniform superposition of $ L $ basis states using the <code>ZeroAncillaUSP</code> method, the following non-Clifford gate overhead is required:</p> In\u00a0[13]: Copied! <pre>zeroanc_usp_dict = {\n    \"name\": \"zeroanc_usp\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"in\", \"direction\": \"input\", \"size\": \"R\"},\n        {\"name\": \"out\", \"direction\": \"output\", \"size\": \"R\"},\n    ],\n    \"input_params\": [\"L\"],\n    \"local_variables\": {\n        \"l_0\": \"trailing(L)\",\n        \"R\": \"ceil(log2(L))\",\n        \"l_k\": \"floor(log2(L))\",\n        \"k\": \"bin_bitcount(L) - 1 \",\n    },\n    \"resources\": [\n        {\"name\": \"ry\", \"type\": \"additive\", \"value\": \"1\"},\n        {\"name\": \"control_ry\", \"type\": \"additive\", \"value\": \"k - 1\"},\n        {\"name\": \"control_H\", \"type\": \"additive\", \"value\": \"l_k - l_0\"},\n    ],\n}\n</pre> zeroanc_usp_dict = {     \"name\": \"zeroanc_usp\",     \"type\": None,     \"ports\": [         {\"name\": \"in\", \"direction\": \"input\", \"size\": \"R\"},         {\"name\": \"out\", \"direction\": \"output\", \"size\": \"R\"},     ],     \"input_params\": [\"L\"],     \"local_variables\": {         \"l_0\": \"trailing(L)\",         \"R\": \"ceil(log2(L))\",         \"l_k\": \"floor(log2(L))\",         \"k\": \"bin_bitcount(L) - 1 \",     },     \"resources\": [         {\"name\": \"ry\", \"type\": \"additive\", \"value\": \"1\"},         {\"name\": \"control_ry\", \"type\": \"additive\", \"value\": \"k - 1\"},         {\"name\": \"control_H\", \"type\": \"additive\", \"value\": \"l_k - l_0\"},     ], } <p>As you can see, we use custom functions <code>trailing</code> and <code>bin_bitcount</code> \u2013 that's fine, because Bartiq can handle arbitrary functions, but we'll also define them later.</p> In\u00a0[14]: Copied! <pre>uncompiled_zeroanc = SchemaV1(version=\"v1\", program=zeroanc_usp_dict)\n</pre> uncompiled_zeroanc = SchemaV1(version=\"v1\", program=zeroanc_usp_dict) <p>Here is the resource expression for <code>ZeroAncillaUSP</code>:</p> In\u00a0[15]: Copied! <pre>for resource in uncompiled_zeroanc.program.resources:\n    print(f\"{resource.name}: {resource.value}\")\n</pre> for resource in uncompiled_zeroanc.program.resources:     print(f\"{resource.name}: {resource.value}\") <pre>control_H: l_k - l_0\ncontrol_ry: k - 1\nry: 1\n</pre> <p>Again, we decompose the <code>control_ry</code> and <code>control_H</code> gates to T gate approximations:</p> <ul> <li>control_ry: A controlled $R_Y (\\theta)$ gate, which contains 2 ry gates after decomposition.</li> <li>control_H: A controlled Hadamard gate, contains 2 T gates after gate synthesis.</li> <li>$R_Y (\\theta)$: A ry gate, similar to an rz gate, can be approximated by about 50 T gates with $\\epsilon = 0.001$.</li> </ul> In\u00a0[16]: Copied! <pre>compiled_zeroanc = compile_routine(uncompiled_zeroanc).routine\naggregation_dict = {\"control_ry\": {\"ry\": 2}, \"control_H\": {\"T_gates\": 2}, \"ry\": {\"T_gates\": 50}}\naggregated_zeroanc = add_aggregated_resources(compiled_zeroanc, aggregation_dict)\nfor resource in aggregated_zeroanc.resources.values():\n    print(f\"{resource.name}: {resource.value}\")\n</pre> compiled_zeroanc = compile_routine(uncompiled_zeroanc).routine aggregation_dict = {\"control_ry\": {\"ry\": 2}, \"control_H\": {\"T_gates\": 2}, \"ry\": {\"T_gates\": 50}} aggregated_zeroanc = add_aggregated_resources(compiled_zeroanc, aggregation_dict) for resource in aggregated_zeroanc.resources.values():     print(f\"{resource.name}: {resource.value}\") <pre>T_gates: 100*bin_bitcount(L) - 2*trailing(L) + 2*floor(log2(L)) - 150\n</pre> In\u00a0[17]: Copied! <pre>import sympy\n\n\ndef trailing(x):\n    return sympy.trailing(x)\n\n\ndef bin_bitcount(x):\n    return bin(x).count(\"1\")\n\n\nfunctions_map = {\"trailing\": trailing, \"bin_bitcount\": bin_bitcount}\nvalues = [3, 5, 6, 7, 9, 10, 12, 14, 15]\nassignments_list = [{\"L\": value} for value in values]\n\nfor assignments in assignments_list:\n    evaluated_zeroanc = evaluate(aggregated_zeroanc, assignments, functions_map=functions_map).routine\n    print(f\"Assignment: {assignments}\")\n    for resource in evaluated_zeroanc.resources.values():\n        print(f\"  {resource.name}: {resource.value}\")\n</pre> import sympy   def trailing(x):     return sympy.trailing(x)   def bin_bitcount(x):     return bin(x).count(\"1\")   functions_map = {\"trailing\": trailing, \"bin_bitcount\": bin_bitcount} values = [3, 5, 6, 7, 9, 10, 12, 14, 15] assignments_list = [{\"L\": value} for value in values]  for assignments in assignments_list:     evaluated_zeroanc = evaluate(aggregated_zeroanc, assignments, functions_map=functions_map).routine     print(f\"Assignment: {assignments}\")     for resource in evaluated_zeroanc.resources.values():         print(f\"  {resource.name}: {resource.value}\") <pre>Assignment: {'L': 3}\n  T_gates: 52\nAssignment: {'L': 5}\n  T_gates: 54\nAssignment: {'L': 6}\n  T_gates: 52\nAssignment: {'L': 7}\n  T_gates: 154\nAssignment: {'L': 9}\n  T_gates: 56\nAssignment: {'L': 10}\n  T_gates: 54\nAssignment: {'L': 12}\n  T_gates: 52\nAssignment: {'L': 14}\n  T_gates: 154\nAssignment: {'L': 15}\n  T_gates: 256\n</pre> <p>As a variation of the method described in Encoding Electronic Spectra...\u00a0\u29c9, we introduce another approach to state preparation using inequality tests, known as the Repeat-Until-Success (RUS) USP.</p> In\u00a0[18]: Copied! <pre>rus_usp_dict = {\n    \"name\": \"rus_usp\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"in\", \"direction\": \"input\", \"size\": \"R\"},\n        {\"name\": \"out\", \"direction\": \"output\", \"size\": \"R\"},\n    ],\n    \"input_params\": [\"L\"],\n    \"local_variables\": {\"k\": \"multiplicity(2,L)\", \"R\": \"ceiling(log_2(L))\", \"trial\": \"num_iter(L)\"},\n    \"resources\": [\n        {\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"4*trial*ceil(log_2(L/(2 ** k))-1)\"},\n        {\"name\": \"ancilla\", \"type\": \"additive\", \"value\": \"floor(log_2(L/2 ** k))\"},\n    ],\n}\n</pre> rus_usp_dict = {     \"name\": \"rus_usp\",     \"type\": None,     \"ports\": [         {\"name\": \"in\", \"direction\": \"input\", \"size\": \"R\"},         {\"name\": \"out\", \"direction\": \"output\", \"size\": \"R\"},     ],     \"input_params\": [\"L\"],     \"local_variables\": {\"k\": \"multiplicity(2,L)\", \"R\": \"ceiling(log_2(L))\", \"trial\": \"num_iter(L)\"},     \"resources\": [         {\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"4*trial*ceil(log_2(L/(2 ** k))-1)\"},         {\"name\": \"ancilla\", \"type\": \"additive\", \"value\": \"floor(log_2(L/2 ** k))\"},     ], } In\u00a0[19]: Copied! <pre>uncompiled_rus = SchemaV1(version=\"v1\", program=rus_usp_dict)\n</pre> uncompiled_rus = SchemaV1(version=\"v1\", program=rus_usp_dict) In\u00a0[20]: Copied! <pre>compiled_rus = compile_routine(uncompiled_rus).routine\n\nfor resource in compiled_rus.resources.values():\n    print(f\"{resource.name}: {resource.value}\")\n</pre> compiled_rus = compile_routine(uncompiled_rus).routine  for resource in compiled_rus.resources.values():     print(f\"{resource.name}: {resource.value}\") <pre>T_gates: 4*(ceiling(log2(L/2**multiplicity(2, L))) - 1)*num_iter(L)\nancilla: floor(log2(L/2**multiplicity(2, L)))\n</pre> <p>This estimation arises because it is equivalent to performing two cost inequality tests. Each test has a Toffoli gate count of $\\lceil \\log_2 \\left(L/2^k\\right) \\rceil - 1$. According to Halving the cost of quantum addition\u00a0\u29c9, when the input of the target is known to be in $| 0 \\rangle$, each Toffoli gate can be decomposed into 4 T gates. Additionally, the T gate cost for the uncompute inequality test (the second one) can be ignored.</p> <p>Now let's look at how to calculate <code>num_iter(L)</code>.</p> <p>The probability of success in each trial is determined by the ratio of $L$ to the smallest power of 2 that is greater than or equal to  $L$. This function  below provides a rough estimation of the number of trials needed to achieve a target success probability (default is 99%) based on the geometric distribution. This means it may not match the actual number of trials required each time, as the process is probabilistic, but gives us the estimation for an average case.</p> <p>Here's how you can estimate the number of trials:</p> In\u00a0[21]: Copied! <pre>import math\n\ndef calculate_trials(d, target_probability=0.99):\n    prob = d / (1 &lt;&lt; math.ceil(math.log2(d)))\n    return math.ceil(math.log(1 - target_probability) / math.log(1 - prob))\n</pre> import math  def calculate_trials(d, target_probability=0.99):     prob = d / (1 &lt;&lt; math.ceil(math.log2(d)))     return math.ceil(math.log(1 - target_probability) / math.log(1 - prob)) In\u00a0[22]: Copied! <pre>L = 7\nnum_trials = calculate_trials(7)\nprint(f\"For L={L}, the estimated number of trials needed is: {num_trials}\")\n</pre> L = 7 num_trials = calculate_trials(7) print(f\"For L={L}, the estimated number of trials needed is: {num_trials}\") <pre>For L=7, the estimated number of trials needed is: 3\n</pre> In\u00a0[23]: Copied! <pre>values = [3, 5, 6, 7, 9, 10, 12, 14, 15]\nassignments_list = [{\"L\":value} for value in values]\n\nfunctions_map = {\"num_iter\": calculate_trials}\n\nfor assignments in assignments_list:\n    evaluated_rus = evaluate(compiled_rus, assignments, functions_map=functions_map).routine\n    print(f\"Assignment: {assignments}\")\n    for resource in evaluated_rus.resources.values():\n        print(f\"  {resource.name}: {resource.value}\")\n</pre> values = [3, 5, 6, 7, 9, 10, 12, 14, 15] assignments_list = [{\"L\":value} for value in values]  functions_map = {\"num_iter\": calculate_trials}  for assignments in assignments_list:     evaluated_rus = evaluate(compiled_rus, assignments, functions_map=functions_map).routine     print(f\"Assignment: {assignments}\")     for resource in evaluated_rus.resources.values():         print(f\"  {resource.name}: {resource.value}\") <pre>Assignment: {'L': 3}\n  T_gates: 16\n  ancilla: 1\nAssignment: {'L': 5}\n  T_gates: 40\n  ancilla: 2\nAssignment: {'L': 6}\n  T_gates: 16\n  ancilla: 1\nAssignment: {'L': 7}\n  T_gates: 24\n  ancilla: 2\nAssignment: {'L': 9}\n  T_gates: 72\n  ancilla: 3\nAssignment: {'L': 10}\n  T_gates: 40\n  ancilla: 2\nAssignment: {'L': 12}\n  T_gates: 16\n  ancilla: 1\nAssignment: {'L': 14}\n  T_gates: 24\n  ancilla: 2\nAssignment: {'L': 15}\n  T_gates: 24\n  ancilla: 3\n</pre> <p>Now, we can compare the cost performance of different USP methods for some concrete data.</p> <p>Here, we generate some instances that are not powers of 2 (when $L$ is a power of 2, only Hadamard gates are needed).</p> In\u00a0[24]: Copied! <pre>def is_power_of_two(n):\n    return (n &amp; (n - 1) == 0) and n != 0\n\n\nall_values = [x for x in range(5, 600) if not is_power_of_two(x)]\nL_values = all_values\n</pre> def is_power_of_two(n):     return (n &amp; (n - 1) == 0) and n != 0   all_values = [x for x in range(5, 600) if not is_power_of_two(x)] L_values = all_values In\u00a0[25]: Copied! <pre># USP\nusp_tgates = []\nusp_ancilla = []\n\nfor L in L_values:\n    assignments_list = {\"L\":L}\n    evaluated_usp = evaluate(aggregated_usp, assignments_list).routine\n    usp_tgates.append(math.ceil(float(evaluated_usp.resources[\"T_gates\"].value)))\n    if \"ancilla\" in evaluated_usp.resources:\n        usp_ancilla.append(int(evaluated_usp.resources[\"ancilla\"].value))\n    else:\n        usp_ancilla.append(0)\n</pre> # USP usp_tgates = [] usp_ancilla = []  for L in L_values:     assignments_list = {\"L\":L}     evaluated_usp = evaluate(aggregated_usp, assignments_list).routine     usp_tgates.append(math.ceil(float(evaluated_usp.resources[\"T_gates\"].value)))     if \"ancilla\" in evaluated_usp.resources:         usp_ancilla.append(int(evaluated_usp.resources[\"ancilla\"].value))     else:         usp_ancilla.append(0) In\u00a0[26]: Copied! <pre># Zeroanc_USP\nzeroanc_tgates = []\nzeroanc_ancilla = []\n\nfunctions_map = {\"trailing\": trailing, \"bin_bitcount\": bin_bitcount}\n\nfor L in L_values:\n    assignments_list = {\"L\":L}\n    evaluated_zeroanc = evaluate(aggregated_zeroanc, assignments_list, functions_map=functions_map).routine\n    zeroanc_tgates.append(int(evaluated_zeroanc.resources[\"T_gates\"].value))\n    if \"ancilla\" in evaluated_zeroanc.resources:\n        zeroanc_ancilla.append(int(evaluated_zeroanc.resources[\"ancilla\"].value))\n    else:\n        zeroanc_ancilla.append(0)\n</pre> # Zeroanc_USP zeroanc_tgates = [] zeroanc_ancilla = []  functions_map = {\"trailing\": trailing, \"bin_bitcount\": bin_bitcount}  for L in L_values:     assignments_list = {\"L\":L}     evaluated_zeroanc = evaluate(aggregated_zeroanc, assignments_list, functions_map=functions_map).routine     zeroanc_tgates.append(int(evaluated_zeroanc.resources[\"T_gates\"].value))     if \"ancilla\" in evaluated_zeroanc.resources:         zeroanc_ancilla.append(int(evaluated_zeroanc.resources[\"ancilla\"].value))     else:         zeroanc_ancilla.append(0) In\u00a0[27]: Copied! <pre># RUS_USP\nrus_tgates = []\nrus_ancilla = []\n\nfunctions_map = {\"num_iter\": calculate_trials}\n\nfor L in L_values:\n    assignments_list = {\"L\":L}\n    evaluated_rus = evaluate(compiled_rus, assignments_list, functions_map=functions_map).routine\n    rus_tgates.append(int(evaluated_rus.resources[\"T_gates\"].value))\n    if \"ancilla\" in evaluated_rus.resources:\n        rus_ancilla.append(int(evaluated_rus.resources[\"ancilla\"].value))\n    else:\n        rus_ancilla.append(0)\n</pre> # RUS_USP rus_tgates = [] rus_ancilla = []  functions_map = {\"num_iter\": calculate_trials}  for L in L_values:     assignments_list = {\"L\":L}     evaluated_rus = evaluate(compiled_rus, assignments_list, functions_map=functions_map).routine     rus_tgates.append(int(evaluated_rus.resources[\"T_gates\"].value))     if \"ancilla\" in evaluated_rus.resources:         rus_ancilla.append(int(evaluated_rus.resources[\"ancilla\"].value))     else:         rus_ancilla.append(0) In\u00a0[28]: Copied! <pre>import matplotlib.pyplot as plt\n\nplt.figure(figsize=(12, 8))\n\nplt.plot(L_values, usp_tgates, label=\"usp\", marker=\"o\", color=\"steelblue\", markersize=4, linestyle=\"--\")\nplt.plot(L_values, zeroanc_tgates, label=\"zeroanc_usp\", marker=\"*\", color=\"magenta\", markersize=4, linestyle=\"-\")\nplt.plot(L_values, rus_tgates, label=\"rus_usp\", marker=\".\", color=\"orange\", markersize=4, linestyle=\"-\")\n\nplt.title(\"Number of T Gates Needed by Different USP Methods\", fontsize=16, fontweight=\"bold\")\nplt.xlabel(\"L\", fontsize=14)\nplt.ylabel(\"Number of T Gates\", fontsize=14)\n\nplt.legend(title=\"Methods\", fontsize=12, title_fontsize=\"13\", loc=\"upper left\", frameon=True, edgecolor=\"black\")\nplt.legend().get_frame().set_facecolor(\"lightgrey\")\n\nplt.grid(True, which=\"both\", linestyle=\"--\", linewidth=0.5)\n\nplt.tight_layout()\nplt.show()\n</pre> import matplotlib.pyplot as plt  plt.figure(figsize=(12, 8))  plt.plot(L_values, usp_tgates, label=\"usp\", marker=\"o\", color=\"steelblue\", markersize=4, linestyle=\"--\") plt.plot(L_values, zeroanc_tgates, label=\"zeroanc_usp\", marker=\"*\", color=\"magenta\", markersize=4, linestyle=\"-\") plt.plot(L_values, rus_tgates, label=\"rus_usp\", marker=\".\", color=\"orange\", markersize=4, linestyle=\"-\")  plt.title(\"Number of T Gates Needed by Different USP Methods\", fontsize=16, fontweight=\"bold\") plt.xlabel(\"L\", fontsize=14) plt.ylabel(\"Number of T Gates\", fontsize=14)  plt.legend(title=\"Methods\", fontsize=12, title_fontsize=\"13\", loc=\"upper left\", frameon=True, edgecolor=\"black\") plt.legend().get_frame().set_facecolor(\"lightgrey\")  plt.grid(True, which=\"both\", linestyle=\"--\", linewidth=0.5)  plt.tight_layout() plt.show() In\u00a0[29]: Copied! <pre>plt.figure(figsize=(12, 8))\n\nplt.plot(L_values, usp_ancilla, label=\"usp\", marker=\"o\", color=\"steelblue\", markersize=6, linestyle=\"--\")\nplt.plot(L_values, zeroanc_ancilla, label=\"zeroanc_usp\", marker=\"*\", color=\"magenta\", markersize=6, linestyle=\"-\")\nplt.plot(L_values, rus_ancilla, label=\"rus_usp\", marker=\".\", color=\"orange\", markersize=6, linestyle=\"-\")\n\nplt.title(\"Number of Ancilla Qubits Needed by Different USP Methods\", fontsize=16, fontweight=\"bold\")\nplt.xlabel(\"L\", fontsize=14)\nplt.ylabel(\"Number of ancillas\", fontsize=14)\n\nplt.legend(title=\"Methods\", fontsize=12, title_fontsize=\"13\", loc=\"upper left\", frameon=True, edgecolor=\"black\")\nplt.legend().get_frame().set_facecolor(\"lightgrey\")\n\nplt.grid(True, which=\"both\", linestyle=\"--\", linewidth=0.5)\n\nplt.tight_layout()\nplt.show()\n</pre> plt.figure(figsize=(12, 8))  plt.plot(L_values, usp_ancilla, label=\"usp\", marker=\"o\", color=\"steelblue\", markersize=6, linestyle=\"--\") plt.plot(L_values, zeroanc_ancilla, label=\"zeroanc_usp\", marker=\"*\", color=\"magenta\", markersize=6, linestyle=\"-\") plt.plot(L_values, rus_ancilla, label=\"rus_usp\", marker=\".\", color=\"orange\", markersize=6, linestyle=\"-\")  plt.title(\"Number of Ancilla Qubits Needed by Different USP Methods\", fontsize=16, fontweight=\"bold\") plt.xlabel(\"L\", fontsize=14) plt.ylabel(\"Number of ancillas\", fontsize=14)  plt.legend(title=\"Methods\", fontsize=12, title_fontsize=\"13\", loc=\"upper left\", frameon=True, edgecolor=\"black\") plt.legend().get_frame().set_facecolor(\"lightgrey\")  plt.grid(True, which=\"both\", linestyle=\"--\", linewidth=0.5)  plt.tight_layout() plt.show() <p>...and we leave the analysis up to you! Decide by yourself which USP implementation suits your needs best!</p> <p>Finally, we'll explore integrating different USP expressions into Alias Sampling. By substituting various USP formulations, we'll see how these changes impact the overall expression and sampling results.</p> <p>Since substituting subroutines is easiest at the level of QREF dictionaries what we'll do is:</p> <ul> <li>take Alias Sampling routine</li> <li>replace the <code>usp</code> subroutine with another dictionary</li> <li>rename it to <code>usp</code> to make sure the connections are valid</li> </ul> In\u00a0[30]: Copied! <pre>import copy\n\n# usp\nas_usp_dict = copy.copy(as_data)\nas_usp_dict[\"program\"][\"children\"][0] = usp_dict\n\ncompiled_as_usp = compile_routine(SchemaV1(**as_usp_dict)).routine\n</pre> import copy  # usp as_usp_dict = copy.copy(as_data) as_usp_dict[\"program\"][\"children\"][0] = usp_dict  compiled_as_usp = compile_routine(SchemaV1(**as_usp_dict)).routine In\u00a0[31]: Copied! <pre># zeroanc_usp\nas_zeroanc_usp_dict = copy.copy(as_data)\nzeroanc_usp_dict[\"name\"] = \"usp\"\nas_zeroanc_usp_dict[\"program\"][\"children\"][0] = zeroanc_usp_dict\n\ncompiled_as_zeroanc = compile_routine(SchemaV1(**as_zeroanc_usp_dict)).routine\n</pre> # zeroanc_usp as_zeroanc_usp_dict = copy.copy(as_data) zeroanc_usp_dict[\"name\"] = \"usp\" as_zeroanc_usp_dict[\"program\"][\"children\"][0] = zeroanc_usp_dict  compiled_as_zeroanc = compile_routine(SchemaV1(**as_zeroanc_usp_dict)).routine In\u00a0[32]: Copied! <pre># rus_usp\nas_rus_usp_dict = copy.copy(as_data)\nrus_usp_dict[\"name\"] = \"usp\"\nas_rus_usp_dict[\"program\"][\"children\"][0] = rus_usp_dict\n\ncompiled_as_rus = compile_routine(SchemaV1(**as_rus_usp_dict)).routine\n</pre> # rus_usp as_rus_usp_dict = copy.copy(as_data) rus_usp_dict[\"name\"] = \"usp\" as_rus_usp_dict[\"program\"][\"children\"][0] = rus_usp_dict  compiled_as_rus = compile_routine(SchemaV1(**as_rus_usp_dict)).routine <p>Now we'll just once again add the aggregated costs, this time using the same <code>aggregation_dict</code> for all the routines:</p> In\u00a0[33]: Copied! <pre>aggregation_dict = {\"control_ry\": {\"ry\": 2}, \"control_H\": {\"T_gates\": 2}, \"ry\": {\"T_gates\": 50}, \"rz\": {\"T_gates\": 50}}\ncompiled_as_usp = add_aggregated_resources(compiled_as_usp, aggregation_dict)\ncompiled_as_zeroanc = add_aggregated_resources(compiled_as_zeroanc, aggregation_dict)\ncompiled_as_rus = add_aggregated_resources(compiled_as_rus, aggregation_dict)\n</pre> aggregation_dict = {\"control_ry\": {\"ry\": 2}, \"control_H\": {\"T_gates\": 2}, \"ry\": {\"T_gates\": 50}, \"rz\": {\"T_gates\": 50}} compiled_as_usp = add_aggregated_resources(compiled_as_usp, aggregation_dict) compiled_as_zeroanc = add_aggregated_resources(compiled_as_zeroanc, aggregation_dict) compiled_as_rus = add_aggregated_resources(compiled_as_rus, aggregation_dict)   In\u00a0[34]: Copied! <pre>from sympy import symbols, Function, sympify, latex, expand, Add\n\ntrailing, binbitcount, multiplicity, numiter, O = map(\n    Function, [\"trailing\", \"bin-bitcount\", \"multiplicity\", \"num-iter\", \"O\"]\n)\nL, mu = symbols(\"L mu\")\n\nT_count = {\n    \"usp\": compiled_as_usp.resources[\"T_gates\"].value,\n    \"anc\": compiled_as_zeroanc.resources[\"T_gates\"].value,\n    \"rus\": compiled_as_rus.resources[\"T_gates\"].value,\n}\nlocals_dict = {\n    \"multiplicity\": multiplicity,\n    \"O\": O,\n    \"bin_bitcount\": binbitcount,\n    \"trailing\": trailing,\n    \"num_iter\": numiter,\n}\nexpr_usp, expr_anc, expr_rus = [sympify(T_count[key], locals=locals_dict) for key in [\"usp\", \"anc\", \"rus\"]]\n</pre> from sympy import symbols, Function, sympify, latex, expand, Add  trailing, binbitcount, multiplicity, numiter, O = map(     Function, [\"trailing\", \"bin-bitcount\", \"multiplicity\", \"num-iter\", \"O\"] ) L, mu = symbols(\"L mu\")  T_count = {     \"usp\": compiled_as_usp.resources[\"T_gates\"].value,     \"anc\": compiled_as_zeroanc.resources[\"T_gates\"].value,     \"rus\": compiled_as_rus.resources[\"T_gates\"].value, } locals_dict = {     \"multiplicity\": multiplicity,     \"O\": O,     \"bin_bitcount\": binbitcount,     \"trailing\": trailing,     \"num_iter\": numiter, } expr_usp, expr_anc, expr_rus = [sympify(T_count[key], locals=locals_dict) for key in [\"usp\", \"anc\", \"rus\"]] In\u00a0[35]: Copied! <pre>from IPython.display import display, Math\n\n# Find the common term in these expressions\ncommon_expr = sum(\n    set(Add.make_args(expand(expr_usp))) &amp; set(Add.make_args(expand(expr_anc))) &amp; set(Add.make_args(expand(expr_rus)))\n)\n\ndisplay(Math(f\"\\\\text{{Common Terms in Alias Sampling with Different USPs: }} {latex(common_expr)}\"))\n</pre> from IPython.display import display, Math  # Find the common term in these expressions common_expr = sum(     set(Add.make_args(expand(expr_usp))) &amp; set(Add.make_args(expand(expr_anc))) &amp; set(Add.make_args(expand(expr_rus))) )  display(Math(f\"\\\\text{{Common Terms in Alias Sampling with Different USPs: }} {latex(common_expr)}\"))  $\\displaystyle \\text{Common Terms in Alias Sampling with Different USPs: } 4 L + 4 \\mu + O{\\left(\\operatorname{log}_{2}{\\left(L \\right)} \\right)}$  In\u00a0[36]: Copied! <pre>display(Math(f\"\\\\text{{Differential Terms Using the USP Method: }} {latex(expr_usp - common_expr)}\"))\ndisplay(Math(f\"\\\\text{{Differential Terms Using the Zero Ancilla USP Method: }}  {latex(expr_anc - common_expr)}\"))\ndisplay(Math(f\"\\\\text{{Difference Terms Using the RUS\\\\_USP Method: }}{latex(expr_rus - common_expr)}\"))\n</pre> display(Math(f\"\\\\text{{Differential Terms Using the USP Method: }} {latex(expr_usp - common_expr)}\")) display(Math(f\"\\\\text{{Differential Terms Using the Zero Ancilla USP Method: }}  {latex(expr_anc - common_expr)}\")) display(Math(f\"\\\\text{{Difference Terms Using the RUS\\\\_USP Method: }}{latex(expr_rus - common_expr)}\"))  $\\displaystyle \\text{Differential Terms Using the USP Method: } 12 \\left\\lceil{\\operatorname{log}_{2}{\\left(2^{- \\operatorname{multiplicity}{\\left(2,L \\right)}} L \\right)}}\\right\\rceil + 76$   $\\displaystyle \\text{Differential Terms Using the Zero Ancilla USP Method: }  100 \\operatorname{bin}_{bitcount}{\\left(L \\right)} - 2 \\operatorname{trailing}{\\left(L \\right)} + 2 \\left\\lfloor{\\operatorname{log}_{2}{\\left(L \\right)}}\\right\\rfloor - 158$   $\\displaystyle \\text{Difference Terms Using the RUS\\_USP Method: }4 \\left(\\left\\lceil{\\operatorname{log}_{2}{\\left(2^{- \\operatorname{multiplicity}{\\left(2,L \\right)}} L \\right)}}\\right\\rceil - 1\\right) \\operatorname{num}_{iter}{\\left(L \\right)} - 8$"},{"location":"tutorials/03_advanced_examples/#using-bartiq-for-resource-analysis","title":"Using bartiq for Resource Analysis\u00b6","text":""},{"location":"tutorials/03_advanced_examples/#usp-implementations","title":"USP Implementations\u00b6","text":"<p>Let's start by setting up different USP routines in <code>bartiq</code>.</p> <p>We will analyze three distinct uniform state preparation routines:</p> <ol> <li>USP: The basic uniform state preparation routine introduced in Encoding Electronic Spectra...\u00a0\u29c9, also the one used in tutorial 02\u00a0\u29c9.</li> <li>ZeroAncillaUSP: A more recent construction that eliminates the need for any ancilla qubits, as presented in An efficient quantum algorithm for preparation of uniform quantum superposition states\u00a0\u29c9.</li> <li>RUS_USP:  A variation of the method described in Encoding Electronic Spectra...\u00a0\u29c9, using Repeat-Until-Success approach.</li> </ol> <p>Throughout this notebook, we will refer to these routines as <code>USP</code>, <code>ZeroAncillaUSP</code> and <code>RUS_USP</code> respectively.</p>"},{"location":"tutorials/03_advanced_examples/#usp","title":"USP\u00b6","text":""},{"location":"tutorials/03_advanced_examples/#parameters","title":"Parameters\u00b6","text":"<p>To prepares a state which is a uniform superposition over $L$ basis states:</p> <ul> <li>$L$: Number of coefficients we want to load.</li> <li>$k$: The largest integer such that $2^k$ divides $L$ , $k = \\textrm{multiplicity}(2, L)$.</li> </ul> <p>Note: These expressions only valid if $L$ is not a power of two, as in such case we can trivially implement USP using a layer of Hadamard gates.</p>"},{"location":"tutorials/03_advanced_examples/#visualizion-of-the-usp-routine","title":"Visualizion of the <code>USP</code> routine\u00b6","text":""},{"location":"tutorials/03_advanced_examples/#numerical-evaluation-examples","title":"Numerical Evaluation Examples\u00b6","text":""},{"location":"tutorials/03_advanced_examples/#zero-ancilla-usp","title":"Zero Ancilla USP\u00b6","text":""},{"location":"tutorials/03_advanced_examples/#non-clifford-gate-overhead","title":"Non-Clifford Gate Overhead\u00b6","text":"<ul> <li>$R_Y (\\theta)$ gate: 1.</li> <li>Controlled Hadamard gate: $l_k - l_0$.</li> <li>Controlled-$R_Y (\\theta)$ gate: $k - 1$.</li> </ul>"},{"location":"tutorials/03_advanced_examples/#parameters","title":"Parameters\u00b6","text":"<ul> <li>$l_0, l_1, \\ldots, l_k$: This is a sequence of integers where $L = \\sum_{j=0}^k 2^{l_j}$ and $0 \\le l_0 &lt; l_1 &lt; \\ldots &lt; l_{k-1} &lt; l_k \\le n-1$. In simpler terms:<ul> <li>$l_0$ is the position of the trailing zero in the binary representation of $L$.</li> <li>$l_k$ is the position of the highest set bit, or $\\lfloor \\log_2(L) \\rfloor$.</li> <li>$k$ is the number of non-zero bits in the binary representation of $L$. Note: This is different from $k$ in <code>USP</code>.</li> </ul> </li> </ul> <p>Using these parameters, you can determine the specific gate overhead required for the <code>ZeroAncillaUSP</code> method in <code>bartiq</code>.</p>"},{"location":"tutorials/03_advanced_examples/#numerical-evaluation-examples","title":"Numerical Evaluation Examples\u00b6","text":""},{"location":"tutorials/03_advanced_examples/#repeat-until-success-rus-usp","title":"Repeat-Until-Success (RUS) USP\u00b6","text":""},{"location":"tutorials/03_advanced_examples/#what-is-rus","title":"What is RUS?\u00b6","text":"<p>The Repeat-Until-Success (RUS) method is a probabilistic technique where attempts are repeatedly made until a successful result is achieved. Failed attempts are discarded, and only the final successful state is retained. Comparing to the method described in Encoding Electronic Spectra...\u00a0\u29c9, <code>RUS_USP</code> omits the amplitude amplification step, but requires a non-deterministic number of repetitions.</p>"},{"location":"tutorials/03_advanced_examples/#resource-estimation-for-repetition","title":"Resource Estimation for Repetition\u00b6","text":"<p>Below, we symbolically estimate the resources required for <code>RUS_USP</code>:</p>"},{"location":"tutorials/03_advanced_examples/#repetition-number","title":"Repetition Number\u00b6","text":""},{"location":"tutorials/03_advanced_examples/#total-resource-estimation","title":"Total Resource Estimation\u00b6","text":"<p>By combining the estimated repetition number with the resource estimation for a single repetition, we can do the numeric evaluation of the total resources required.</p>"},{"location":"tutorials/03_advanced_examples/#comparison","title":"Comparison\u00b6","text":""},{"location":"tutorials/03_advanced_examples/#make-the-samples","title":"Make the Samples\u00b6","text":""},{"location":"tutorials/03_advanced_examples/#resource-estimation","title":"Resource Estimation\u00b6","text":""},{"location":"tutorials/03_advanced_examples/#plotting-the-result-of-t_gates","title":"Plotting the Result of T_gates\u00b6","text":""},{"location":"tutorials/03_advanced_examples/#plotting-the-results-of-ancilla-qubits","title":"Plotting the Results of Ancilla Qubits\u00b6","text":""},{"location":"tutorials/03_advanced_examples/#alias-sampling-with-different-usp","title":"Alias Sampling with Different USP\u00b6","text":""},{"location":"tutorials/03_advanced_examples/#summary","title":"Summary\u00b6","text":"<p>In this tutorial, we explored the utility of <code>bartiq</code>'s resource estimation in more complex scenarios.</p> <ul> <li>How to explore how different implementations of a subroutine influence the resources required. TODO rephrase</li> <li>How to effectively utilize <code>bartiq</code> to handle nested subroutines and swap them.</li> <li>How to use aggregation functions to help us analyzing the problem.</li> </ul>"}]}