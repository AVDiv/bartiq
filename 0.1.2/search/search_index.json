{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Bartiq","text":""},{"location":"#intro","title":"Intro","text":"<p>Bartiq is a library that allows to analyze a quantum algorithms and calculate symbolic expressions for quantum resource estimates (QRE).</p>"},{"location":"#installation","title":"Installation","text":"<p>To install <code>bartiq</code> run: <code>pip install bartiq</code>. For more details follow instructions on the installation page.</p>"},{"location":"#quick-start","title":"Quick start","text":"<p>In Bartiq we take a quantum algorithm expressed as a collection of subroutines, each with it's costs expressed as symbolic expressions, and compile it to get cost expression for the whole algorithm.</p> <p>As an example we use Alias Sampling \u2013\u00a0an algorithm proposed by Babbush et al.\u00a0\u29c9. Here's how it's depicted in the paper:</p> <p></p> <p>In order to quickly get started with <code>bartiq</code>, you can load Alias Sampling as an example routine and use it as follows (click here to download <code>alias_sampling_basic.json</code>):</p> <pre><code>import json\nfrom bartiq import Routine, compile_routine, evaluate\nfrom bartiq.integrations import qref_to_bartiq\n\nwith open(\"alias_sampling_basic.json\", \"r\") as f:\n    routine_dict = json.load(f)\n\nuncompiled_routine = qref_to_bartiq(routine_dict)\ncompiled_routine = compile_routine(uncompiled_routine)\n\nassignments = [\"L=100\", \"mu=10\"]\n\nevaluated_routine = evaluate(compiled_routine, assignments)\n</code></pre> <p>Now in order to inspect the results you can do:</p> <pre><code>print(compiled_routine.resources[\"T_gates\"].value)\nprint(evaluated_routine.resources[\"T_gates\"].value)\n</code></pre> <p>which returns both the symbolic expression for the T-count as well as the specific values of <code>L</code> and <code>mu</code>:</p> <pre><code>4*L + 8*L/multiplicity(2, L) + 4*mu + swap.O(log2(L)) - 8\nswap.O(log2(100)) + 832\n</code></pre>"},{"location":"#next-steps","title":"Next steps","text":"<ul> <li>For a more comprehensive step-by-step examples, please see tutorials.</li> <li>If you are interested in learning more about how <code>bartiq</code> works under the hood, please see the concepts tab in the menu.</li> <li>For common issues, please check troubleshooting section.</li> <li>You can find reference documentation for the public API of <code>bartiq</code>'s python package, please go to reference.</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#basic","title":"Basic","text":"<p>To install <code>bartiq</code> run: </p> <pre><code>pip install bartiq\n</code></pre>"},{"location":"installation/#from-source","title":"From Source","text":"<p>For a source install run:</p> <pre><code># Clone bartiq repo (you can use HTTP link as well)\ngit clone git@github.com:PsiQ/bartiq.git\ncd bartiq\npip install .\n</code></pre>"},{"location":"installation/#development","title":"Development","text":"<p>For development we recommend installing using <code>poetry</code>: </p> <pre><code>git clone git@github.com:PsiQ/bartiq.git\ncd bartiq\npip install poetry\npoetry install\n</code></pre> <p>This will create a virtual environment for you and install all developer and docs dependencies within it.</p> <p>To enter this environment run:</p> <pre><code>poetry shell\n</code></pre>"},{"location":"installation/#tests","title":"Tests","text":"<p>To run the test suite, from the project root directory run:</p> <pre><code>poetry shell  # If not already in the venv\npytest\n</code></pre>"},{"location":"installation/#documentation","title":"Documentation","text":"<p>To build docs, from the project root directory run:</p> <pre><code>poetry shell  # If not already in the venv\nmkdocs serve\n</code></pre>"},{"location":"limitations/","title":"Known limitations","text":"<p>This page lists some prominent limitations and missing features. Please keep in mind that <code>bartiq</code> is currently under active development, so some of these might soon be resolved. For an up-to-date list of all planned features, please see the GitHub issues page\u00a0\u29c9.</p>"},{"location":"limitations/#balance-between-exact-and-approximate-costs","title":"Balance between exact and approximate costs","text":"<p>For some quantum algorithms, the expression for their cost might depend on the inputs. For example, the uncontrolled SWAP gate can be implemented with just 3 CNOTs (no T gates), but the controlled version requires using T gates, depending on the number of controls. This effectively introduces a conditional cost. It can be modelled using bartiq in a couple of ways: - using a step function (Heaviside theta) allows to model cases where the cost has different values depending if given parameter is below or above certain threshold. - using piecewise sympy function\u00a0\u29c9 - using user-defined functions instead of sympy expressions</p> <p>However, all these methods introduce additional complexities which may or may not be appropriate for a given use-case. Ultimately, bartiq does not provide any native approach for dynamic definition of estimators based on circuit topologies, so users are responsible for such decision-making prior to compilation.</p>"},{"location":"limitations/#non-trivial-port-sizes","title":"Non-trivial port sizes","text":"<p>Right now bartiq does not support use of arbitrary expressions for input port sizes, but rather requires input port sizes to be constant or defined by as a single parameter. In the case that this isn't sufficient, it can be somewhat circumvented by introducing <code>local_variables</code>, but it's not elegant solution and might cause some unforeseen issues in the compilation process. Please reach out to a <code>bartiq</code> core developers if you are interested in this use-case and we will support you as needed.</p>"},{"location":"limitations/#qubit-counts","title":"Qubit counts","text":"<p>While finding the size of a particular port/register in bartiq is simple, getting the full qubit count needed for a given algorithm is currently not something that bartiq natively supports, and rather requires such expressions to be defined by user-provided expressions. This is because there are typically subtleties involving counting ancillary qubits which are difficult or impossible to automate, such as algorithmic design choices concerning clean or dirty qubit reuse, etc. </p> <p>(N.B. we hope to support automatic qubit cost tabulation in the future, and so have included <code>qubits</code> as one of the native cost types, although at present it's not being used in any meaningful way.)</p>"},{"location":"limitations/#keeping-track-of-where-given-register-is-being-used","title":"Keeping track of where given register is being used","text":"<p>Bartiq operates purely on ports and connections between routines and hence does not have a concept of persistent qubits registers which exist beyond a single connection. This gives more flexibility in connecting routines and not having to deal with qubits allocation and deallocation. However, it also means that it is not natively possible to query whether the qubits referenced by a given connection correspond to any persistent quantum register or variable.</p>"},{"location":"limitations/#repeated-subroutines","title":"Repeated subroutines","text":"<p>Currently bartiq has limited capability to support a case where a particular subroutine is repeated multiple times. It can be done for a simple case where all the repetitions act on the same qubit registers. However, routines where target register change or we have a recursive definition (such as controlled unitaries in QPE) are not something one can natively support in Bartiq.</p>"},{"location":"reference/","title":"API reference","text":""},{"location":"reference/#bartiq","title":"bartiq","text":""},{"location":"reference/#bartiq.Connection","title":"Connection","text":"<p>             Bases: <code>BaseModel</code></p> <p>Connection between two ports.</p> <p>Attributes:</p> Name Type Description <code>source</code> <code>Port</code> <p>Port which the connection comes from.</p> <code>target</code> <code>Port</code> <p>Port the connection targets.</p> <code>parent</code> <code>Optional[Routine]</code> <p>Routine this connection belongs to. Note: it is marked as Optional only because of how Routine objects are internally constructed. In correctly constructed routines, no actual connection should have a None as a parent.</p>"},{"location":"reference/#bartiq.Port","title":"Port","text":"<p>             Bases: <code>BaseModel</code></p> <p>Class representing a port.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of this port.</p> <code>parent</code> <code>Optional[Routine]</code> <p>Routine to which this port belongs to.</p> <code>direction</code> <code>PortDirection</code> <p>Direction of this port. Port can be either input, output or bidirectional.</p> <code>size</code> <code>Optional[AnnotatedValue]</code> <p>Size of this port. It might be a concrete value or a variable.</p> <code>meta</code> <code>Optional[dict[str, Any]]</code> <p>Additional free-form data associated with this port.</p>"},{"location":"reference/#bartiq.Port.absolute_path","title":"absolute_path  <code>property</code>","text":"<pre><code>absolute_path: str\n</code></pre> <p>Returns a path from root.</p>"},{"location":"reference/#bartiq.PortDirection","title":"PortDirection","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>Class for representing port direction.</p>"},{"location":"reference/#bartiq.Resource","title":"Resource","text":"<p>             Bases: <code>BaseModel</code></p> <p>Resource associated with a routine.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the resource.</p> <code>type</code> <code>ResourceType</code> <p>Type of the resource.</p> <code>parent</code> <code>Optional[Routine]</code> <p>Routine whose resource this object represents.</p> <code>value</code> <code>AnnotatedValue</code> <p>Value of the resources, either concrete one or a variable.</p>"},{"location":"reference/#bartiq.ResourceType","title":"ResourceType","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>Class for representing types of resources.</p>"},{"location":"reference/#bartiq.Routine","title":"Routine","text":"<p>             Bases: <code>BaseModel</code></p> <p>Subroutine in a quantum program.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the subroutine.</p> <code>type</code> <code>Optional[str]</code> <p>Type of the subroutine, might be None.</p> <code>ports</code> <code>dict[str, Port]</code> <p>Dicionary mapping port name to corresponding Port object with the same name.</p> <code>parent</code> <code>Optional[Self]</code> <p>A Routine whose this routine is subroutine of. Might be None, in which case the routine is considered to be root of computation.</p> <code>children</code> <code>dict[str, Routine]</code> <p>Dictionary mapping name of subroutine of this routine into routine object with the same name.</p> <code>connections</code> <code>list[Connection]</code> <p>List of connections objects, containing all the directed edges between either ports of this routine and ports of its children or ports of two children. Importantly, by convention, connection objects cannot descend further then one generation (i.e. there might not be a connection between routine and its grandchild).</p> <code>resources</code> <code>dict[str, Resource]</code> <p>Dictionary mapping name of the resource to corrresponding Resource object.</p> <code>input_params</code> <code>Sequence[Symbol]</code> <p>Sequence of symbols determining inputs for this routine.</p> <code>local_variables</code> <code>list[str]</code> <p>Convenience aliases to expressions commonly used within this Routine. For instance, for a Routine with input parameter d one of the local variables can be N=ceil(log_2(d)).</p> <code>linked_params</code> <code>dict[Symbol, list[tuple[Routine, Symbol]]]</code> <p>Dictionary defining relations between parameters of this routine and parameters of its children. This dictionary is keyed with this routine's symbols, with the corresponding values being list of pairs (child, param) to which the symbol is connected to. Unlike connections, parameters links might descend further than one generation.</p> <code>meta</code> <code>Optional[dict[str, Any]]</code> <p>Addictional free-form information associated with this routine.</p>"},{"location":"reference/#bartiq.Routine.absolute_path","title":"absolute_path  <code>property</code>","text":"<pre><code>absolute_path: str\n</code></pre> <p>Returns a path from root.</p>"},{"location":"reference/#bartiq.Routine.input_ports","title":"input_ports  <code>property</code>","text":"<pre><code>input_ports: dict[str, Port]\n</code></pre> <p>Dictionary of input ports of this routine.</p>"},{"location":"reference/#bartiq.Routine.is_leaf","title":"is_leaf  <code>property</code>","text":"<pre><code>is_leaf: bool\n</code></pre> <p>Return True if this routine is a leaf, and false otherwise.</p> <p>By the definition, a routine is a leaf iff it has no children.</p>"},{"location":"reference/#bartiq.Routine.is_root","title":"is_root  <code>property</code>","text":"<pre><code>is_root: bool\n</code></pre> <p>Return True if this routine is a root, and false otherwise.</p> <p>By the definition, a routine is a root iff it doesn't have a parent.</p>"},{"location":"reference/#bartiq.Routine.output_ports","title":"output_ports  <code>property</code>","text":"<pre><code>output_ports: dict[str, Port]\n</code></pre> <p>Dictionary of output ports of this routine.</p>"},{"location":"reference/#bartiq.Routine.find_descendant","title":"find_descendant","text":"<pre><code>find_descendant(selector: str) -&gt; Routine\n</code></pre> <p>Given a selector of a child, return the corresponding routine.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>str</code> <p>a string comprising sequence of names determining the child. For instance, a string \"a.b.c\" mean child with name \"c\" of routine with name \"b\", which itself is a child of routine \"a\" which is a child of self. If empty string is provided, returns itself.</p> required <p>Returns:</p> Type Description <code>Routine</code> <p>Routine corresponding to given selector.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if given child is not found.</p>"},{"location":"reference/#bartiq.Routine.relative_path_from","title":"relative_path_from","text":"<pre><code>relative_path_from(ancestor: Optional[Routine]) -&gt; str\n</code></pre> <p>Return relative path to the ancestor.</p> <p>Parameters:</p> Name Type Description Default <code>ancestor</code> <code>Optional[Routine]</code> <p>Ancestor from which a relative path to self should be found.</p> required <p>Returns:</p> Type Description <code>str</code> <p>selector s such that ancestor.find_descendant(s) is self.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If ancestor is not, in fact, an ancestor of self.</p>"},{"location":"reference/#bartiq.Routine.walk","title":"walk","text":"<pre><code>walk() -&gt; Iterable[Self]\n</code></pre> <p>Iterates through all the ancestry, deep-first.</p>"},{"location":"reference/#bartiq.compile_routine","title":"compile_routine","text":"<pre><code>compile_routine(\n    routine,\n    *,\n    backend=sympy_backend,\n    precompilation_stages=None,\n    global_functions=None,\n    functions_map=None\n)\n</code></pre> <p>Compile estimates for given uncompiled Routine.</p> <p>Parameters:</p> Name Type Description Default <code>routine</code> <p>Routine to be compiled</p> required <code>backend</code> <p>The backend to use for manipulating symbolic expressions. Defaults to sympy_backend.</p> <code>sympy_backend</code> <code>precompilation_stages</code> <p>a list of precompilation stages which should be applied. If <code>None</code>, default precompilation stages are used.</p> <code>None</code> <code>global_functions</code> <p>functions in the cost expressions which we don't want to have namespaced.</p> <code>None</code> <code>functions_map</code> <p>a dictionary which specifies non-standard functions which need to applied during compilation.</p> <code>None</code>"},{"location":"reference/#bartiq.evaluate","title":"evaluate","text":"<pre><code>evaluate(\n    routine,\n    assignments,\n    *,\n    backend=sympy_backend,\n    functions_map=None\n) -&gt; Routine\n</code></pre> <p>Evaluates an estimate of a series of variable assignments.</p> <p>Parameters:</p> Name Type Description Default <code>routine</code> <p>Routine to evaluate. Note: this must have been compiled already.</p> required <code>assignments</code> <p>A list of variable assignments, such as <code>['x = 10', 'y = 3.141']</code>.</p> required <code>backend</code> <p>A backend used for manipulating symbolic expressions.</p> <code>sympy_backend</code> <code>functions_map</code> <p>A dictionary with string keys and callable functions as values. If any of the routines contains a function matching the key in this dict, it will be replaced by calling corresponding value of this dict.</p> <code>None</code> <p>Returns:</p> Type Description <code>Routine</code> <p>A new estimate with variables assigned to the desired values.</p>"},{"location":"reference/#bartiq.precompilation","title":"bartiq.precompilation","text":""},{"location":"reference/#bartiq.precompilation.AddPassthroughPlaceholder","title":"AddPassthroughPlaceholder","text":""},{"location":"reference/#bartiq.precompilation.AddPassthroughPlaceholder.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> <p>Contrary to other precompilation methods, this one is stateful (and therefore implemented as a class), to ensure unique name and register size for each passhtrough.</p>"},{"location":"reference/#bartiq.precompilation.AddPassthroughPlaceholder.add_passthrough_placeholders","title":"add_passthrough_placeholders","text":"<pre><code>add_passthrough_placeholders(\n    routine: Routine, _backend: SymbolicBackend\n) -&gt; None\n</code></pre> <p>Detects when a passthrough occurs in given routine and removes it. Passthroughs are problematic for the compilation process and are removed by adding \"identity routines\". This changes the topology of the routine, but it functionally stays the same.</p> <p>NOTE: To work properly it needs to be used before remove_non_root_container_input_register_sizes.</p>"},{"location":"reference/#bartiq.precompilation.add_default_additive_costs","title":"add_default_additive_costs","text":"<pre><code>add_default_additive_costs(\n    routine: Routine, _backend: SymbolicBackend\n) -&gt; None\n</code></pre> <p>Adds an additive resources to routine if any of the children contains them.</p> <p>If given routine: - has children, - children have defined some additive resources - is missing some these resources, it adds the resource which is sum of the costs in subroutines.</p>"},{"location":"reference/#bartiq.precompilation.add_default_properties","title":"add_default_properties","text":"<pre><code>add_default_properties(\n    routine: Routine,\n    _backend: SymbolicBackend,\n    defaults: Optional[DefaultsMap] = None,\n) -&gt; None\n</code></pre> <p>Adds a default resources/port sizes to a routine based on its type.</p>"},{"location":"reference/#bartiq.precompilation.default_precompilation_stages","title":"default_precompilation_stages","text":"<pre><code>default_precompilation_stages()\n</code></pre> <p>Default suite of precompilation stages.</p>"},{"location":"reference/#bartiq.precompilation.precompile","title":"precompile","text":"<pre><code>precompile(\n    routine: Routine,\n    backend,\n    precompilation_stages: Optional[\n        list[PrecompilationStage]\n    ] = None,\n) -&gt; Routine\n</code></pre> <p>A precompilation stage that transforms a routine prior to estimate compilation.</p> <p>If no precompilation stages are specified, the following precompilation stages are performed by default (in order): 1. Adds default costs and register sizes for the following routine types:   - <code>merge</code> 2. Adds additive costs to routines if there's an additive cost in any of the children. 3. Adds \"fake routines\" when passthrough is detected. 4. Removes input register sizes from non-root routines as they will be derived from the connected output ports     in the compilation process. 5. Replaces wildcard statements (\"~\") with appropriate expressions.</p> <p>Parameters:</p> Name Type Description Default <code>routine</code> <code>Routine</code> <p>A uncompiled routine.</p> required <code>precompilation_stages</code> <code>Optional[list[PrecompilationStage]]</code> <p>A list of functions that modify routine and all it's sub-routines in place.</p> <code>None</code>"},{"location":"reference/#bartiq.precompilation.remove_non_root_container_input_register_sizes","title":"remove_non_root_container_input_register_sizes","text":"<pre><code>remove_non_root_container_input_register_sizes(\n    routine: Routine, _backend: SymbolicBackend\n) -&gt; None\n</code></pre> <p>Removes any non-root container inputer register sizes defined.</p>"},{"location":"reference/#bartiq.precompilation.unroll_wildcarded_costs","title":"unroll_wildcarded_costs","text":"<pre><code>unroll_wildcarded_costs(\n    routine: Routine, backend: SymbolicBackend\n) -&gt; None\n</code></pre> <p>Unrolls wildcarded expressions in the resources using information from its children. Right now it supports only non-nested expressions.</p>"},{"location":"reference/#bartiq.symbolics","title":"bartiq.symbolics","text":""},{"location":"reference/#bartiq.routing","title":"bartiq.routing","text":""},{"location":"reference/#bartiq.routing.get_port_source","title":"get_port_source","text":"<pre><code>get_port_source(port: Port) -&gt; Port\n</code></pre> <p>Finds the port's source port, i.e. the terminal port reached by following upstream connections. It ignores the intermediate ports, like parent's ports, which only facilitate connections through layers of hierarchy, but do not provide meaningful inputs.</p>"},{"location":"reference/#bartiq.routing.get_port_target","title":"get_port_target","text":"<pre><code>get_port_target(port: Port) -&gt; Port\n</code></pre> <p>Finds port's target port, i.e. the terminal port reached by following downstream connections. It ignores the intermediate ports, like parent's ports, which only facilitate connections through layers of hierarchy, but do not provide meaningful inputs.</p>"},{"location":"reference/#bartiq.routing.get_route","title":"get_route","text":"<pre><code>get_route(port: Port, forward: bool = True) -&gt; list[Port]\n</code></pre> <p>Returns a list of all the ports that will be encountered when following particular port in either direction.</p>"},{"location":"reference/#bartiq.routing.join_paths","title":"join_paths","text":"<pre><code>join_paths(*paths: str) -&gt; str\n</code></pre> <p>Helper function for joining paths in a routine.</p>"},{"location":"reference/#bartiq.errors","title":"bartiq.errors","text":""},{"location":"reference/#bartiq.errors.BartiqCompilationError","title":"BartiqCompilationError","text":"<p>             Bases: <code>Exception</code></p> <p>Raised for errors during Bartiq function compilation.</p>"},{"location":"reference/#bartiq.errors.BartiqPrecompilationError","title":"BartiqPrecompilationError","text":"<p>             Bases: <code>Exception</code></p> <p>Raised for errors during Bartiq function pre-compilation.</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>Debugging <code>bartiq</code> is not always straightforward, so please see below for a number of best practices and common issues:</p> <ul> <li> <p>Bartiq routines can get pretty complicated very quickly, especially if nested subroutines are involved. Therefore when you get an error, try isolating the issue and work on a smaller example:</p> <ul> <li>First make sure that each child subroutine compiles correctly on its own. If not, this might suggest where the issue is.</li> <li>Try removing all the unnecessary fields, children, connections, etc. and prepare a minimal failing example.</li> </ul> </li> <li> <p>Take a look at the list of issues on GitHub\u00a0\u29c9 and see if other didn't have a similar problem!</p> <ul> <li>If not, consider creating one!</li> <li>Submitting issue is the most transparent way to give us feedback \u2013 even if something works, but is extremely unintuitive, we want to make it easier to use. The goal of this tool is to save you time, not waste it on unhelpful error messages.</li> </ul> </li> <li> <p>If you see a <code>passthrough</code> in your error message, but you don't know where it came from, passthroughs are added automatically during one of the precompilation stages.</p> </li> </ul>"},{"location":"concepts/compilation/","title":"Compilation","text":""},{"location":"concepts/data_format/","title":"Data format","text":""},{"location":"concepts/evaluation/","title":"Evaluation","text":""},{"location":"concepts/precompilation/","title":"Precompilation","text":""},{"location":"concepts/symbolics/","title":"Symbolics","text":""},{"location":"tutorials/","title":"Introduction","text":"<p>We currently have two tutorials for <code>bartiq</code>:</p> <ul> <li>Basic example</li> <li>Alias Sampling basic</li> </ul> <p>They have been designed to gradually introduce you to the concepts we use in <code>bartiq</code>, so we recommend to go through them in order.</p>"},{"location":"tutorials/01_basic_example/","title":"Basic example","text":"<p>In this tutorial our goals are to learn:</p> <ul> <li>How to use <code>bartiq</code> to implement a quantum algorithm from a paper.</li> <li>How to obtain resource estimates for that algorithm.</li> <li>What the most important concepts used in <code>bartiq</code> are.</li> </ul> <p>NOTE:</p> <p>This tutorial, as well as all the other tutorials, has been written as a jupyter notebook. If you're reading it online, you can either keep reading, or go to <code>docs/tutorials</code> to explore them in a more interactive way!</p> <p>Before we start implementing some real algorithms, let's consider the following simple routine:</p> <p></p> <p>In <code>bartiq</code> we call our main object <code>Routine</code> \u2013 both the whole algorithm here, as well as each operation will be a <code>Routine</code>. So what do we know about the routines from the picture above?</p> <ul> <li>Our main routine is called \"my algorithm\"</li> <li>It consists of two subroutines: \"A\" and \"B\".</li> <li>It takes in a register of size \"n\".</li> </ul> <p>How do we express this in <code>bartiq</code>? We do that using the <code>QREF</code> format\u00a0\u29c9 \u2013 a format for expressing algorithms that we developed with QREs in mind. So let's write our first routine:</p> In\u00a0[1]: Copied! <pre>my_algorithm = {\n    \"name\": \"my_algorithm\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"in\", \"direction\": \"input\", \"size\": \"n\"},\n        {\"name\": \"out\", \"direction\": \"output\", \"size\": None},\n    ],\n}\n</pre> my_algorithm = {     \"name\": \"my_algorithm\",     \"type\": None,     \"ports\": [         {\"name\": \"in\", \"direction\": \"input\", \"size\": \"n\"},         {\"name\": \"out\", \"direction\": \"output\", \"size\": None},     ], } <p>What do we have here?</p> <ul> <li><code>name</code>: name of the routine</li> <li><code>type</code>: in this case we don't define the type, but in more complex algorithms you might want to add types, such as \"basic_gate\" or \"comparator\".</li> <li><code>ports</code>: ports define the interface of the routine. The size of the input port is equal to <code>n</code> and in general, we won't know the size of the output port until we perform the compilation.</li> </ul> <p>What are we missing? Children.</p> <p>Before we add them to the main routine we need to define them though.</p> In\u00a0[2]: Copied! <pre>routine_a = {\n    \"name\": \"A\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"in\", \"direction\": \"input\", \"size\": \"n_a\"},\n        {\"name\": \"out\", \"direction\": \"output\", \"size\": \"2*n_a\"},\n    ],\n}\n</pre> routine_a = {     \"name\": \"A\",     \"type\": None,     \"ports\": [         {\"name\": \"in\", \"direction\": \"input\", \"size\": \"n_a\"},         {\"name\": \"out\", \"direction\": \"output\", \"size\": \"2*n_a\"},     ], } <p>Notice, that the sizes of input and output ports don't need to match. Here we defined that the size of the output port is twice the size of the input.</p> In\u00a0[3]: Copied! <pre>routine_b = {\n    \"name\": \"B\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"in\", \"direction\": \"input\", \"size\": \"n_b\"},\n         # \"y\" will be defined in the next step\n        {\"name\": \"out\", \"direction\": \"output\", \"size\": \"n_b + y\"},\n    ],\n}\n</pre> routine_b = {     \"name\": \"B\",     \"type\": None,     \"ports\": [         {\"name\": \"in\", \"direction\": \"input\", \"size\": \"n_b\"},          # \"y\" will be defined in the next step         {\"name\": \"out\", \"direction\": \"output\", \"size\": \"n_b + y\"},     ], } <p>We will need to know how much each subroutine costs if we want to run the resource estimation. In fault-tolerant quantum computation a common metric of interest is an algorithm's T-gate count. (T-gates are a particular quantum gate which are typically more expensive to implement than other quantum gates, and so are commonly used as the standard metric for an algorithm's computational cost.)</p> <p>In this example, let's say that routine <code>A</code> costs <code>2*n_a + x</code> T gates and routine <code>B</code> costs <code>n_b*ceil(log_2(n_b)) * y</code> T-gates, where <code>x</code> and <code>y</code> are some arbitrary paremeters.</p> <p>Knowing T-gate costs and sizes of parameters, we can now visualize subroutines <code>A</code> and <code>B</code> like this:</p> <p></p> <p>This will require adding two new fields to the dictionaries defining <code>A</code> and <code>B</code> respectively:</p> In\u00a0[4]: Copied! <pre># Define T-gate counts for routine a\nroutine_a[\"input_params\"] = [\"x\"]\nroutine_a[\"resources\"] = [\n    {\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"2*n_a + x\"}\n]\n\n# Define T-gate counts for routine b\nroutine_b[\"input_params\"] = [\"y\"]\nroutine_b[\"resources\"] = [\n    {\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"n_b*ceil(log_2(n_b)) * y\"}\n]\n</pre> # Define T-gate counts for routine a routine_a[\"input_params\"] = [\"x\"] routine_a[\"resources\"] = [     {\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"2*n_a + x\"} ]  # Define T-gate counts for routine b routine_b[\"input_params\"] = [\"y\"] routine_b[\"resources\"] = [     {\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"n_b*ceil(log_2(n_b)) * y\"} ] <p>As you can see we added two new fields to our dictionaries:</p> <ul> <li><code>input_params</code>: which defines the variables used by the routine's resource expressions.</li> <li><code>resources</code>: which defines the resource costs for our routine. As you can see resources have the following fields:<ul> <li><code>name</code>: name of the resource</li> <li><code>type</code>: <code>bartiq</code> allows for the following types: <code>additive</code>, <code>multiplicative</code>, <code>qubits</code> and <code>other</code>.</li> <li><code>value</code>: expression (or numeric value) defining the cost.</li> </ul> </li> </ul> <p>Now that <code>routine_a</code> and <code>routine_b</code> are complete, we can add the missing components to <code>my_algorithm</code>:</p> In\u00a0[5]: Copied! <pre>my_algorithm[\"children\"] = [routine_a, routine_b]\nmy_algorithm[\"connections\"] = [\n    {\"source\": \"in\", \"target\": \"A.in\"},\n    {\"source\": \"A.out\", \"target\": \"B.in\"},\n    {\"source\": \"B.out\", \"target\": \"out\"},\n]\nmy_algorithm[\"input_params\"] = [\"z\"]\nmy_algorithm[\"linked_params\"] = [{\"source\": \"z\", \"targets\": [\"A.x\", \"B.y\"]}]\n</pre> my_algorithm[\"children\"] = [routine_a, routine_b] my_algorithm[\"connections\"] = [     {\"source\": \"in\", \"target\": \"A.in\"},     {\"source\": \"A.out\", \"target\": \"B.in\"},     {\"source\": \"B.out\", \"target\": \"out\"}, ] my_algorithm[\"input_params\"] = [\"z\"] my_algorithm[\"linked_params\"] = [{\"source\": \"z\", \"targets\": [\"A.x\", \"B.y\"]}] <p>The new things we have here are:</p> <ul> <li><code>connections</code>: defines how routines are connected via their ports. Each connection has source and target.</li> <li><code>children</code>: defines a routine's subroutines.</li> <li><code>linked_params</code>: defines how input parameters used by the parent are linked to the parameters of children. In this case, it specifies that the input parameter <code>z</code> should be passed as <code>x</code> to the subroutine <code>A</code> and as <code>y</code> to <code>B</code>. Note that we don't need to pass information about <code>n</code>, <code>n_a</code> and <code>n_b</code>, as this information gets passed through the connections.</li> </ul> <p>The last step is just a formality to indicate which version of QREF schema we use:</p> In\u00a0[6]: Copied! <pre>my_algorithm_qref = {'version': 'v1', 'program': my_algorithm}\n</pre> my_algorithm_qref = {'version': 'v1', 'program': my_algorithm} <p>Now we can translate our algorithm into a proper <code>bartiq</code> routine and see what's the total cost of <code>my_algorithm</code>.</p> <p>Below you can find depiction of <code>my_algorithm</code>. </p> <p>We can create <code>bartiq</code> <code>Routine</code> from <code>QREF</code> definition by simply running:</p> In\u00a0[7]: Copied! <pre>from bartiq.integrations import qref_to_bartiq\nuncompiled_routine = qref_to_bartiq(my_algorithm_qref)\n</pre> from bartiq.integrations import qref_to_bartiq uncompiled_routine = qref_to_bartiq(my_algorithm_qref) <p>What does \"uncompiled\" means here?</p> <p>It means that all the costs and register sizes are expressed using local variables (as in the picture above). What does it mean? Look at this:</p> In\u00a0[8]: Copied! <pre>uncompiled_routine.children[\"A\"].resources\n</pre> uncompiled_routine.children[\"A\"].resources Out[8]: <pre>{'T_gates': &lt;Resource name=\"T_gates\" value=\"2*n_a + x\"&gt;}</pre> <p>The cost of <code>A</code> is still expressed in terms of its own \"local\" variables, <code>n_a</code> and <code>x</code>. Information that we included in <code>linked_params</code> has not yet been propagated into <code>A</code>.</p> <p>We also don't know yet what's the size of the output port:</p> In\u00a0[9]: Copied! <pre>uncompiled_routine.ports[\"out\"]\n</pre> uncompiled_routine.ports[\"out\"] Out[9]: <pre>Port(name='out', parent=&lt;Routine name=\"my_algorithm\"&gt;, direction='output', size=None, meta={})</pre> <p>Most importantly, we don't know what is the total cost of the algorithm:</p> In\u00a0[10]: Copied! <pre>uncompiled_routine.resources\n</pre> uncompiled_routine.resources Out[10]: <pre>{}</pre> <p>So what we want to do, is to get to the following picture: </p> <p>You can compare it with the previous picture and see how \"local\" variables have been replaced with \"global\" ones.</p> <p>We do this with the following command:</p> In\u00a0[11]: Copied! <pre>from bartiq import compile_routine\ncompiled_routine = compile_routine(uncompiled_routine)\n</pre> from bartiq import compile_routine compiled_routine = compile_routine(uncompiled_routine) <p>Now let's check the same fields of our <code>compiled_routine</code> object:</p> In\u00a0[12]: Copied! <pre>print(\"T gates for A:\", compiled_routine.children[\"A\"].resources[\"T_gates\"].value)\nprint(\"Output size:\", compiled_routine.ports[\"out\"].size)\nprint(\"Total T gates:\", compiled_routine.resources[\"T_gates\"].value)\n</pre> print(\"T gates for A:\", compiled_routine.children[\"A\"].resources[\"T_gates\"].value) print(\"Output size:\", compiled_routine.ports[\"out\"].size) print(\"Total T gates:\", compiled_routine.resources[\"T_gates\"].value) <pre>T gates for A: 2*n + z\nOutput size: 2*n + z\nTotal T gates: 2*n*z*ceiling(log2(2*n)) + 2*n + z\n</pre> <p>Since the resources in the children have type <code>additive</code>, <code>bartiq</code> automatically added the <code>T_gates</code> resource to the parent as a sum of the resources of the children.</p> <p>Now it would be good to know what is the cost when we subsitute some numbers. We can do this using <code>evaluate</code> method. As you can see in the example below, it can either take all the parameters or just some of them.</p> In\u00a0[13]: Copied! <pre>from bartiq import evaluate\n\nprint(\"Different values of n:\")\nfor n in range(6, 16, 2):\n    assignments = [f\"n={n}\"]\n    evaluated_routine = evaluate(compiled_routine, assignments)\n    print(f\"n = {n}, total T gates:\", evaluated_routine.resources[\"T_gates\"].value)\n\nz=5\nassignments = [f\"n={n}\", f\"z={z}\"]\nevaluated_routine = evaluate(compiled_routine, assignments)\nprint(f\"For n={n}, z={z}\")\n\nprint(\"Total T gates:\", evaluated_routine.resources[\"T_gates\"].value)\n</pre> from bartiq import evaluate  print(\"Different values of n:\") for n in range(6, 16, 2):     assignments = [f\"n={n}\"]     evaluated_routine = evaluate(compiled_routine, assignments)     print(f\"n = {n}, total T gates:\", evaluated_routine.resources[\"T_gates\"].value)  z=5 assignments = [f\"n={n}\", f\"z={z}\"] evaluated_routine = evaluate(compiled_routine, assignments) print(f\"For n={n}, z={z}\")  print(\"Total T gates:\", evaluated_routine.resources[\"T_gates\"].value) <pre>Different values of n:\nn = 6, total T gates: 49*z + 12\nn = 8, total T gates: 65*z + 16\nn = 10, total T gates: 101*z + 20\nn = 12, total T gates: 121*z + 24\nn = 14, total T gates: 141*z + 28\nFor n=14, z=5\nTotal T gates: 733\n</pre>"},{"location":"tutorials/01_basic_example/#basic-example","title":"Basic example\u00b6","text":""},{"location":"tutorials/01_basic_example/#compilation","title":"Compilation\u00b6","text":""},{"location":"tutorials/01_basic_example/#evaluation","title":"Evaluation\u00b6","text":""},{"location":"tutorials/01_basic_example/#summary","title":"Summary\u00b6","text":"<p>Let's sum up what we covered in this tutorial:</p> <ul> <li>How to construct a simple algorithm in <code>bartiq</code></li> <li>How to compile an estimate</li> <li>How to evaluate an estimate</li> </ul> <p>In the next tutorial we'll cover how to implement a more complex algorithm from a paper.</p>"},{"location":"tutorials/02_alias_sampling_basic/","title":"Alias Sampling","text":"<p>NOTE:</p> <p>This tutorial, as well as all the other tutorials, has been written as a jupyter notebook. If you're reading it online, you can either keep reading, or go to <code>docs/tutorials</code> to explore them in a more interactive way!</p> <p>The example we used in previous tutorial was nice to establish some basic terminology. But let's be honest, it was contrived and not very practical. So now we'll take an existing example from a paper and try to get some resource estimations for it using <code>bartiq</code>!</p> <p>For that we'll use Alias Sampling\u2014an algorithm proposed by Babbush et al. in Encoding Electronic Spectra in Quantum Circuits with Linear T Complexity\u00a0\u29c9. This is what the circuit looks like:</p> <p></p> <p>It comes from Fig. 11 from the original paper.</p> <p>This circuit is an important subroutine in the paper's larger algorithm because it is responsible for preparing arbitrary quantum states, which can be thought of as \"loading\" data into the quantum computer.</p> <p>In this tutorial we won't be explaining how the algorithm works in details\u2014partly because this is not the place, and partly because Craig Gidney already did it in his blogpost\u00a0\u29c9</p> <p>But briefly and at a high level, Alias Sampling contains the following subroutines:</p> <ul> <li>$\\textrm{UNIFORM}_L$:\u00a0prepares a state which is a uniform superposition over $L$ basis states</li> <li>$H^{\\otimes\\mu}$: applies a set of Hadamard gates to create a uniform superposition over $2^{\\mu}$ basis states</li> <li>QROM: loads data values into two \"data\" registers in superposition depending on the state input to $\\textrm{In}_{\\ell}$</li> <li>Comparator:\u00a0flips a target qubit if $\\textrm{keep}_l \\leq \\sigma_l$ based on the values of the two other input registers (to $\\textrm{In}_{\\sigma_l}$ and $\\textrm{In}_{\\textrm{keep}_l}$ respectively).</li> <li>Controlled SWAP: swaps two target registers conditional on the value of a control qubit.</li> </ul> <p>Now, before we map all these subroutines to <code>bartiq</code>, it would be good to know what the costs of each of the subroutines are. After carefully reading the paper we can deduce what the costs are. But before we get there, let's define our symbols to have consistent naming.  The authors use same letters for different variables in different figures, so it can get confusing without reading the paper carefully\u2014that's why we'll stick to the naming from the figure above to keep things simple.</p> <ul> <li>$L$ \u2013\u00a0number of coefficients we want to load.</li> <li>$\\mu$ \u2013 bits of precision for coefficients we load.</li> <li>$k$ is the greatest common factor of $L$. This is not a widely-used mathematical operation, but fortunately in <code>bartiq</code> we have a shorthand for that, and we can say that <code>k = multiplicity(2, L)</code>. For more information, you can check how it's defined in sympy\u00a0\u29c9.</li> </ul> <p>Given all that\u2014what are the costs of our routines? For the purpose of we shall focus on just calculating the T-gate and rotation costs:</p> <ul> <li>Uniform: $8\\log_2(L/k)$ T-gates and 2 rotation gates. It comes Fig 12 and its caption. We omit the $O(\\log(1/\\epsilon)$ term, because it corresponds to those two rotations that we count separately.</li> <li>Hadamards: No T-gates or rotations.</li> <li>QROM: $4L-4$ \u2013 this comes from Fig. 10.</li> <li>Comparator: $4\\mu-4$ \u2013\u00a0this is not stated explicitly in the text, but comes from a careful analysis of the caption of Fig. 11.</li> <li>Swap: $O(\\log_2(L))$ \u2013 this is not stated explicitly in the text, but comes from a careful analysis of the caption of Fig. 11.</li> </ul> <p>These expressions don't take into account some nuances\u2014for example the uniform state preparation (USP) can be implemented as a layer of Hadamard gates if $L$ is a power of two.</p> <p>Armed with this knowledge, we can now write each individual routine. However, since in this case all the routines have similar structure, we can use the following helper function:</p> <p>NOTE:</p> <p>Unfortunately the costs presented in this example are quite complicated. It would be great to just point you to a single place in the paper, get an expression and type it into <code>bartiq</code>. That's not the case though and if there are any mistakes or oversimplifications\u2014please let us know! However, the fact that even a relatively simple routine presents such challenges, shows that we need better tools for working with quantum algorithms.</p> <p>Also, as it turns out in the follow-up work not all the costs from this paper are correct, as some routines can be optimized. But explaining that is way beyond the scope of this tutorial.</p> In\u00a0[1]: Copied! <pre>usp_dict = {\n    \"name\": \"usp\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"in\", \"direction\": \"input\", \"size\": \"R\"},\n        {\"name\": \"out\", \"direction\": \"output\", \"size\": \"R\"},\n    ],\n    \"resources\": [\n        {\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"8*L/multiplicity(2,L)\"},\n        {\"name\": \"rotations\", \"type\": \"additive\", \"value\": \"2\"},\n    ],\n    \"input_params\": [\"L\"],\n    \"local_variables\": [\"R=ceiling(log_2(L))\"],\n}\n</pre> usp_dict = {     \"name\": \"usp\",     \"type\": None,     \"ports\": [         {\"name\": \"in\", \"direction\": \"input\", \"size\": \"R\"},         {\"name\": \"out\", \"direction\": \"output\", \"size\": \"R\"},     ],     \"resources\": [         {\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"8*L/multiplicity(2,L)\"},         {\"name\": \"rotations\", \"type\": \"additive\", \"value\": \"2\"},     ],     \"input_params\": [\"L\"],     \"local_variables\": [\"R=ceiling(log_2(L))\"], } <p>There are two things that we did here which might not be straight-forward.</p> <ul> <li>We used <code>ceiling</code> function for the port size\u2014that's because port sizes need to be integer.</li> <li>We introduced new field: <code>local_variables</code>. This allows us to define some \"helper\" variables, which are only used in the scope of this routine and save us some typing</li> </ul> In\u00a0[2]: Copied! <pre>had_dict = {\n    \"name\": \"had\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"in\", \"direction\": \"input\", \"size\": \"N\"},\n        {\"name\": \"out\", \"direction\": \"output\", \"size\": \"N\"},\n    ],\n}\n</pre> had_dict = {     \"name\": \"had\",     \"type\": None,     \"ports\": [         {\"name\": \"in\", \"direction\": \"input\", \"size\": \"N\"},         {\"name\": \"out\", \"direction\": \"output\", \"size\": \"N\"},     ], } In\u00a0[3]: Copied! <pre>qrom_dict = {\n    \"name\": \"qrom\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"In_l\", \"direction\": \"input\", \"size\": \"R\"},\n        {\"name\": \"In_alt\", \"direction\": \"input\", \"size\": \"R\"},\n        {\"name\": \"In_keep\", \"direction\": \"input\", \"size\": \"mu\"},\n        {\"name\": \"out_l\", \"direction\": \"output\", \"size\": \"R\"},\n        {\"name\": \"out_alt\", \"direction\": \"output\", \"size\": \"R\"},\n        {\"name\": \"out_keep\", \"direction\": \"output\", \"size\": \"mu\"},\n    ],\n    \"resources\": [{\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"4*L-4\"}],\n    \"input_params\": [\"L\", \"mu\"],\n    \"local_variables\": [\"R=ceiling(log_2(L))\"],\n}\n</pre> qrom_dict = {     \"name\": \"qrom\",     \"type\": None,     \"ports\": [         {\"name\": \"In_l\", \"direction\": \"input\", \"size\": \"R\"},         {\"name\": \"In_alt\", \"direction\": \"input\", \"size\": \"R\"},         {\"name\": \"In_keep\", \"direction\": \"input\", \"size\": \"mu\"},         {\"name\": \"out_l\", \"direction\": \"output\", \"size\": \"R\"},         {\"name\": \"out_alt\", \"direction\": \"output\", \"size\": \"R\"},         {\"name\": \"out_keep\", \"direction\": \"output\", \"size\": \"mu\"},     ],     \"resources\": [{\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"4*L-4\"}],     \"input_params\": [\"L\", \"mu\"],     \"local_variables\": [\"R=ceiling(log_2(L))\"], } In\u00a0[4]: Copied! <pre>compare_dict = {\n    \"name\": \"compare\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"In_sigma\", \"direction\": \"input\", \"size\": \"mu\"},\n        {\"name\": \"In_keep\", \"direction\": \"input\", \"size\": \"mu\"},\n        {\"name\": \"In_flag\", \"direction\": \"input\", \"size\": \"1\"},\n        {\"name\": \"out_sigma\", \"direction\": \"output\", \"size\": \"mu\"},\n        {\"name\": \"out_keep\", \"direction\": \"output\", \"size\": \"mu\"},\n        {\"name\": \"out_flag\", \"direction\": \"output\", \"size\": \"1\"},\n    ],\n    \"resources\": [{\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"4*mu-4\"}],\n    \"input_params\": [\"mu\"],\n}\n</pre> compare_dict = {     \"name\": \"compare\",     \"type\": None,     \"ports\": [         {\"name\": \"In_sigma\", \"direction\": \"input\", \"size\": \"mu\"},         {\"name\": \"In_keep\", \"direction\": \"input\", \"size\": \"mu\"},         {\"name\": \"In_flag\", \"direction\": \"input\", \"size\": \"1\"},         {\"name\": \"out_sigma\", \"direction\": \"output\", \"size\": \"mu\"},         {\"name\": \"out_keep\", \"direction\": \"output\", \"size\": \"mu\"},         {\"name\": \"out_flag\", \"direction\": \"output\", \"size\": \"1\"},     ],     \"resources\": [{\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"4*mu-4\"}],     \"input_params\": [\"mu\"], }  In\u00a0[5]: Copied! <pre>swap_dict = {\n    \"name\": \"swap\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"In_control\", \"direction\": \"input\", \"size\": \"1\"},\n        {\"name\": \"In_target_0\", \"direction\": \"input\", \"size\": \"X\"},\n        {\"name\": \"In_target_1\", \"direction\": \"input\", \"size\": \"X\"},\n        {\"name\": \"out_control\", \"direction\": \"output\", \"size\": None},\n        {\"name\": \"out_target_0\", \"direction\": \"output\", \"size\": None},\n        {\"name\": \"out_target_1\", \"direction\": \"output\", \"size\": None},\n    ],\n    \"resources\": [{\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"O(log_2(X))\"}],\n    \"connections\": [\n        {\"source\": \"In_control\", \"target\": \"out_control\"},\n        {\"source\": \"In_target_0\", \"target\": \"out_target_0\"},\n        {\"source\": \"In_target_1\", \"target\": \"out_target_1\"},\n    ],\n    \"input_params\": [\"X\"],\n}\n</pre> swap_dict = {     \"name\": \"swap\",     \"type\": None,     \"ports\": [         {\"name\": \"In_control\", \"direction\": \"input\", \"size\": \"1\"},         {\"name\": \"In_target_0\", \"direction\": \"input\", \"size\": \"X\"},         {\"name\": \"In_target_1\", \"direction\": \"input\", \"size\": \"X\"},         {\"name\": \"out_control\", \"direction\": \"output\", \"size\": None},         {\"name\": \"out_target_0\", \"direction\": \"output\", \"size\": None},         {\"name\": \"out_target_1\", \"direction\": \"output\", \"size\": None},     ],     \"resources\": [{\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"O(log_2(X))\"}],     \"connections\": [         {\"source\": \"In_control\", \"target\": \"out_control\"},         {\"source\": \"In_target_0\", \"target\": \"out_target_0\"},         {\"source\": \"In_target_1\", \"target\": \"out_target_1\"},     ],     \"input_params\": [\"X\"], }  <p>We follow the same naming convention in all the subroutines to make things easier to follow. But in swap, we decided to use <code>X</code> instead of <code>R=ceil(log_2(L))</code>. Why?</p> <p>It shows, that we can use whatever naming we want for any particular subroutine \u2013 we don't need to stick to one convention in all the subroutines. This is what you would often want to do in practice. If you would like to reuse this controlled swap in some other algorithm, a generic <code>X</code> is a much better choice than a very specific <code>R</code>.</p> <p>Now that we have all these defined, let's construct the dictionary for the whole algorithm:</p> In\u00a0[6]: Copied! <pre>alias_sampling_dict = {\n    \"name\": \"alias_sampling\",\n    \"children\": [usp_dict, had_dict, qrom_dict, compare_dict, swap_dict],\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"In_0\", \"direction\": \"input\", \"size\": \"R\"},\n        {\"name\": \"In_1\", \"direction\": \"input\", \"size\": \"mu\"},\n        {\"name\": \"In_2\", \"direction\": \"input\", \"size\": \"R\"},\n        {\"name\": \"In_3\", \"direction\": \"input\", \"size\": \"mu\"},\n        {\"name\": \"In_4\", \"direction\": \"input\", \"size\": \"1\"},\n        {\"name\": \"out_0\", \"direction\": \"output\", \"size\": None},\n        {\"name\": \"temp_0\", \"direction\": \"output\", \"size\": None},\n        {\"name\": \"temp_1\", \"direction\": \"output\", \"size\": None},\n        {\"name\": \"temp_2\", \"direction\": \"output\", \"size\": None},\n        {\"name\": \"temp_3\", \"direction\": \"output\", \"size\": None},\n    ],\n    \"connections\": [\n        {\"source\": \"In_0\", \"target\": \"usp.in\"},\n        {\"source\": \"In_1\", \"target\": \"had.in\"},\n        {\"source\": \"In_2\", \"target\": \"qrom.In_alt\"},\n        {\"source\": \"In_3\", \"target\": \"qrom.In_keep\"},\n        {\"source\": \"In_4\", \"target\": \"compare.In_flag\"},\n        {\"source\": \"usp.out\", \"target\": \"qrom.In_l\"},\n        {\"source\": \"had.out\", \"target\": \"compare.In_sigma\"},\n        {\"source\": \"qrom.out_l\", \"target\": \"swap.In_target_0\"},\n        {\"source\": \"qrom.out_alt\", \"target\": \"swap.In_target_1\"},\n        {\"source\": \"qrom.out_keep\", \"target\": \"compare.In_keep\"},\n        {\"source\": \"compare.out_flag\", \"target\": \"swap.In_control\"},\n        {\"source\": \"swap.out_target_0\", \"target\": \"out_0\"},\n        {\"source\": \"compare.out_sigma\", \"target\": \"temp_0\"},\n        {\"source\": \"swap.out_target_1\", \"target\": \"temp_1\"},\n        {\"source\": \"compare.out_keep\", \"target\": \"temp_2\"},\n        {\"source\": \"swap.out_control\", \"target\": \"temp_3\"},\n    ],\n    \"input_params\": [\"mu\", \"L\"],\n    \"local_variables\": [\"R=ceiling(log_2(L))\"],\n    \"linked_params\": [\n        {\"source\": \"L\", \"targets\": [\"usp.L\", \"qrom.L\", \"swap.X\"]},\n        {\"source\": \"mu\", \"targets\": [\"had.mu\", \"qrom.mu\", \"compare.mu\"]},\n    ],\n}\n</pre> alias_sampling_dict = {     \"name\": \"alias_sampling\",     \"children\": [usp_dict, had_dict, qrom_dict, compare_dict, swap_dict],     \"type\": None,     \"ports\": [         {\"name\": \"In_0\", \"direction\": \"input\", \"size\": \"R\"},         {\"name\": \"In_1\", \"direction\": \"input\", \"size\": \"mu\"},         {\"name\": \"In_2\", \"direction\": \"input\", \"size\": \"R\"},         {\"name\": \"In_3\", \"direction\": \"input\", \"size\": \"mu\"},         {\"name\": \"In_4\", \"direction\": \"input\", \"size\": \"1\"},         {\"name\": \"out_0\", \"direction\": \"output\", \"size\": None},         {\"name\": \"temp_0\", \"direction\": \"output\", \"size\": None},         {\"name\": \"temp_1\", \"direction\": \"output\", \"size\": None},         {\"name\": \"temp_2\", \"direction\": \"output\", \"size\": None},         {\"name\": \"temp_3\", \"direction\": \"output\", \"size\": None},     ],     \"connections\": [         {\"source\": \"In_0\", \"target\": \"usp.in\"},         {\"source\": \"In_1\", \"target\": \"had.in\"},         {\"source\": \"In_2\", \"target\": \"qrom.In_alt\"},         {\"source\": \"In_3\", \"target\": \"qrom.In_keep\"},         {\"source\": \"In_4\", \"target\": \"compare.In_flag\"},         {\"source\": \"usp.out\", \"target\": \"qrom.In_l\"},         {\"source\": \"had.out\", \"target\": \"compare.In_sigma\"},         {\"source\": \"qrom.out_l\", \"target\": \"swap.In_target_0\"},         {\"source\": \"qrom.out_alt\", \"target\": \"swap.In_target_1\"},         {\"source\": \"qrom.out_keep\", \"target\": \"compare.In_keep\"},         {\"source\": \"compare.out_flag\", \"target\": \"swap.In_control\"},         {\"source\": \"swap.out_target_0\", \"target\": \"out_0\"},         {\"source\": \"compare.out_sigma\", \"target\": \"temp_0\"},         {\"source\": \"swap.out_target_1\", \"target\": \"temp_1\"},         {\"source\": \"compare.out_keep\", \"target\": \"temp_2\"},         {\"source\": \"swap.out_control\", \"target\": \"temp_3\"},     ],     \"input_params\": [\"mu\", \"L\"],     \"local_variables\": [\"R=ceiling(log_2(L))\"],     \"linked_params\": [         {\"source\": \"L\", \"targets\": [\"usp.L\", \"qrom.L\", \"swap.X\"]},         {\"source\": \"mu\", \"targets\": [\"had.mu\", \"qrom.mu\", \"compare.mu\"]},     ], } In\u00a0[7]: Copied! <pre>alias_sampling_qref = {'version': 'v1', 'program': alias_sampling_dict}\n</pre> alias_sampling_qref = {'version': 'v1', 'program': alias_sampling_dict} In\u00a0[8]: Copied! <pre>from bartiq.integrations import qref_to_bartiq\nuncompiled_routine = qref_to_bartiq(alias_sampling_qref)\n</pre> from bartiq.integrations import qref_to_bartiq uncompiled_routine = qref_to_bartiq(alias_sampling_qref) In\u00a0[9]: Copied! <pre>from bartiq import compile_routine\ncompiled_routine = compile_routine(uncompiled_routine)\n</pre> from bartiq import compile_routine compiled_routine = compile_routine(uncompiled_routine) <p>It went pretty well, let's see what's the we got:</p> In\u00a0[10]: Copied! <pre>for resource in compiled_routine.resources.values():\n    print(f\"{resource.name}: {resource.value}\")\n</pre> for resource in compiled_routine.resources.values():     print(f\"{resource.name}: {resource.value}\") <pre>rotations: 2\nT_gates: 4*L + 8*L/multiplicity(2, L) + 4*mu + swap.O(log2(L)) - 8\n</pre> <p>In the caption of Fig. 11 we had: $4(L + \\mu) + O(\\log_2(L))$, and these two expressions actually match pretty well.</p> <ul> <li>We have the $4(L + \\mu)$ in both versions.</li> <li>We have a <code>swap.O(log_2(L))</code> which corresponds to <code>O(log_2(L))</code></li> <li>The <code>8*L/multiplicity(2, L)</code> term is also <code>O(log_2(L))</code></li> <li>Constant factor of <code>-8</code> can also be incorporated in <code>O(log_2(L))</code></li> </ul> <p>Let's see how it looks like for some concrete values:</p> In\u00a0[11]: Copied! <pre>from bartiq import evaluate\nassignments = {\"L=120\", \"mu=8\"}\nevaluated_routine = evaluate(compiled_routine, assignments)\nfor resource in evaluated_routine.resources.values():\n    print(f\"{resource.name}: {resource.value}\")\n</pre> from bartiq import evaluate assignments = {\"L=120\", \"mu=8\"} evaluated_routine = evaluate(compiled_routine, assignments) for resource in evaluated_routine.resources.values():     print(f\"{resource.name}: {resource.value}\") <pre>rotations: 2\nT_gates: swap.O(log2(120)) + 824\n</pre> <p>Well, we're almost there... There's still <code>swap.O()</code> in our expression \u2013 what is it?</p> <p>This is good opportunity to talk about how to substitute arbitrary functions in <code>bartiq</code>!</p> <p>As you can see, the functions in <code>bartiq</code> are namespaced by default \u2013 that's why why we have <code>swap.O</code> rather than <code>O</code>. Alternatively, you can compile your routine with <code>global_functions</code> keyword. That will remove the <code>swap.</code> namespace.</p> In\u00a0[12]: Copied! <pre>compiled_routine = compile_routine(uncompiled_routine, global_functions=[\"O\"])\nfor resource in compiled_routine.resources.values():\n    print(f\"{resource.name}: {resource.value}\")\n</pre> compiled_routine = compile_routine(uncompiled_routine, global_functions=[\"O\"]) for resource in compiled_routine.resources.values():     print(f\"{resource.name}: {resource.value}\") <pre>rotations: 2\nT_gates: 4*L + 8*L/multiplicity(2, L) + 4*mu + O(log2(L)) - 8\n</pre> <p>We still have big O there, but at least now we got rid of the <code>swap</code>. So let's assume the simplest case, i.e.<code>O(x) = x</code>.</p> In\u00a0[13]: Copied! <pre>def big_O(x):\n    return x\n\nfunctions_map = {\"O\": big_O}\nevaluated_routine = evaluate(compiled_routine, assignments, functions_map=functions_map)\nfor resource in evaluated_routine.resources.values():\n    print(f\"{resource.name}: {resource.value}\")\n</pre> def big_O(x):     return x  functions_map = {\"O\": big_O} evaluated_routine = evaluate(compiled_routine, assignments, functions_map=functions_map) for resource in evaluated_routine.resources.values():     print(f\"{resource.name}: {resource.value}\") <pre>rotations: 2\nT_gates: log2(120) + 824\n</pre> <p>And now we finally have some concrete numbers!</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/02_alias_sampling_basic/#alias-sampling","title":"Alias Sampling\u00b6","text":""},{"location":"tutorials/02_alias_sampling_basic/#summary","title":"Summary\u00b6","text":"<p>Let's sum up what we covered in this tutorial:</p> <ul> <li>How to take an algorithm from a paper and compile it into <code>bartiq</code></li> <li>How to create a routine with multiple resources, <code>local_variables</code> and custom functions</li> </ul>"}]}