{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Bartiq","text":""},{"location":"#intro","title":"Intro","text":"<p>Bartiq is a library that allows one to analyze quantum algorithms and calculate symbolic expressions for quantum resource estimates (QRE).</p>"},{"location":"#installation","title":"Installation","text":"<p>To install <code>bartiq</code> run: <code>pip install bartiq</code>. For more details follow instructions on the installation page.</p>"},{"location":"#quick-start","title":"Quick start","text":"<p>In Bartiq we take a quantum algorithm expressed as a collection of subroutines, each with its costs expressed as symbolic expressions, and compile it to get cost expression for the whole algorithm.</p> <p>As an example we use Alias Sampling \u2013\u00a0an algorithm proposed by Babbush et al.\u00a0\u29c9. Here's how it's depicted in the paper:</p> <p></p> <p>In order to quickly get started with <code>bartiq</code>, you can load Alias Sampling as an example routine and use it as follows (click here to download <code>alias_sampling_basic.json</code>):</p> <pre><code>import json\nfrom bartiq import Routine, compile_routine, evaluate\nfrom bartiq.integrations import qref_to_bartiq\n\nwith open(\"alias_sampling_basic.json\", \"r\") as f:\n    routine_dict = json.load(f)\n\nuncompiled_routine = qref_to_bartiq(routine_dict)\ncompiled_routine = compile_routine(uncompiled_routine)\n\nassignments = [\"L=100\", \"mu=10\"]\n\nevaluated_routine = evaluate(compiled_routine, assignments)\n</code></pre> <p>Now in order to inspect the results you can do:</p> <pre><code>print(compiled_routine.resources[\"T_gates\"].value)\nprint(evaluated_routine.resources[\"T_gates\"].value)\n</code></pre> <p>which returns both the symbolic expression for the T-count as well as the specific values of <code>L</code> and <code>mu</code>:</p> <pre><code>4*L + 8*L/multiplicity(2, L) + 4*mu + swap.O(log2(L)) - 8\nswap.O(log2(100)) + 832\n</code></pre>"},{"location":"#next-steps","title":"Next steps","text":"<ul> <li>For a more comprehensive step-by-step examples, please see tutorials.</li> <li>If you are interested in learning more about how <code>bartiq</code> works under the hood, please see the concepts tab in the menu.</li> <li>For common issues, please check troubleshooting section.</li> <li>You can find reference documentation for the public API of <code>bartiq</code>'s python package, please go to reference.</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#basic","title":"Basic","text":"<p>To install <code>bartiq</code> run:</p> <pre><code>pip install bartiq\n</code></pre> <p>Info</p> <p>If you wish to use the package's jupyter integrations, run <code>pip install \"bartiq[jupyter]\"</code> instead.</p>"},{"location":"installation/#from-source","title":"From Source","text":"<p>For a source install run:</p> <pre><code># Clone bartiq repo (you can use HTTP link as well)\ngit clone git@github.com:PsiQ/bartiq.git\ncd bartiq\npip install .\n</code></pre> <p>Info</p> <p>If you wish to use the package's jupyter integrations, run <code>pip install \".[jupyter]\"</code> instead.</p>"},{"location":"installation/#development","title":"Development","text":"<p>For development we recommend installing using <code>poetry</code>:</p> <pre><code>git clone git@github.com:PsiQ/bartiq.git\ncd bartiq\npip install poetry\npoetry install\n</code></pre> <p>Info</p> <p>If you wish to use the package's jupyter integrations, run <code>poetry install -E jupyter</code> instead.</p> <p>This will create a virtual environment for you and install all developer and docs dependencies within it.</p> <p>To enter this environment run:</p> <pre><code>poetry shell\n</code></pre>"},{"location":"installation/#tests","title":"Tests","text":"<p>To run the test suite, from the project root directory run:</p> <pre><code>poetry shell  # If not already in the venv\npytest\n</code></pre>"},{"location":"installation/#documentation","title":"Documentation","text":"<p>To build docs, from the project root directory run:</p> <pre><code>poetry shell  # If not already in the venv\nmkdocs serve\n</code></pre>"},{"location":"limitations/","title":"Known limitations","text":"<p>This page lists some prominent limitations and missing features. Please keep in mind that <code>bartiq</code> is currently under active development, so some of these might soon be resolved. For an up-to-date list of all planned features, please see the GitHub issues page\u00a0\u29c9.</p>"},{"location":"limitations/#balance-between-exact-and-approximate-costs","title":"Balance between exact and approximate costs","text":"<p>For some quantum algorithms, the expression for their cost might depend on the inputs. For example, the uncontrolled SWAP gate can be implemented with just 3 CNOTs (no T gates), but the controlled version requires using T gates, depending on the number of controls. This effectively introduces a conditional cost. It can be modelled using bartiq in a couple of ways: - using a step function (Heaviside theta) allows to model cases where the cost has different values depending if given parameter is below or above certain threshold. - using piecewise sympy function\u00a0\u29c9 - using user-defined functions instead of sympy expressions</p> <p>However, all these methods introduce additional complexities which may or may not be appropriate for a given use-case. Ultimately, bartiq does not provide any native approach for dynamic definition of routines based on the topology, so users are responsible for such decision-making prior to compilation.</p>"},{"location":"limitations/#non-trivial-port-sizes","title":"Non-trivial port sizes","text":"<p>Right now bartiq does not support use of arbitrary expressions for input port sizes, but rather requires input port sizes to be constant or defined by as a single parameter. In the case that this isn't sufficient, it can be somewhat circumvented by introducing <code>local_variables</code>, but it's not elegant solution and might cause some unforeseen issues in the compilation process. Please reach out to a <code>bartiq</code> core developers if you are interested in this use-case and we will support you as needed.</p>"},{"location":"limitations/#qubit-counts","title":"Qubit counts","text":"<p>While finding the size of a particular port/register in bartiq is simple, getting the full qubit count needed for a given algorithm is currently not something that bartiq natively supports, and rather requires such expressions to be defined by user-provided expressions. This is because there are typically subtleties involving counting ancillary qubits which are difficult or impossible to automate, such as algorithmic design choices concerning clean or dirty qubit reuse, etc. </p> <p>(N.B. we hope to support automatic qubit cost tabulation in the future, and so have included <code>qubits</code> as one of the native cost types, although at present it's not being used in any meaningful way.)</p>"},{"location":"limitations/#keeping-track-of-where-given-register-is-being-used","title":"Keeping track of where given register is being used","text":"<p>Bartiq operates purely on ports and connections between routines and hence does not have a concept of persistent qubits registers which exist beyond a single connection. This gives more flexibility in connecting routines and not having to deal with qubits allocation and deallocation. However, it also means that it is not natively possible to query whether the qubits referenced by a given connection correspond to any persistent quantum register or variable.</p>"},{"location":"limitations/#repeated-subroutines","title":"Repeated subroutines","text":"<p>Currently bartiq has limited capability to support a case where a particular subroutine is repeated multiple times. It can be done for a simple case where all the repetitions act on the same qubit registers. However, routines where target register change or we have a recursive definition (such as controlled unitaries in QPE) are not something one can natively support in Bartiq.</p>"},{"location":"reference/","title":"API reference","text":""},{"location":"reference/#bartiq","title":"bartiq","text":""},{"location":"reference/#bartiq.Connection","title":"Connection","text":"<p>             Bases: <code>BaseModel</code></p> <p>Connection between two ports.</p> <p>Attributes:</p> Name Type Description <code>source</code> <code>Port</code> <p>Port which the connection comes from.</p> <code>target</code> <code>Port</code> <p>Port the connection targets.</p> <code>parent</code> <code>Optional[Routine]</code> <p>Routine this connection belongs to. Note: it is marked as Optional only because of how Routine objects are internally constructed. In correctly constructed routines, no actual connection should have a None as a parent.</p>"},{"location":"reference/#bartiq.Port","title":"Port","text":"<p>             Bases: <code>BaseModel</code></p> <p>Class representing a port.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>_Name</code> <p>Name of this port.</p> <code>parent</code> <code>Optional[Routine]</code> <p>Routine to which this port belongs to.</p> <code>direction</code> <code>PortDirection</code> <p>Direction of this port. Port can be either input, output or bidirectional.</p> <code>size</code> <code>Optional[AnnotatedValue]</code> <p>Size of this port. It might be a concrete value or a variable.</p> <code>meta</code> <code>Optional[dict[str, Any]]</code> <p>Additional free-form data associated with this port.</p>"},{"location":"reference/#bartiq.Port.absolute_path","title":"absolute_path","text":"<pre><code>absolute_path(exclude_root_name: bool = False) -&gt; str\n</code></pre> <p>Returns a path from root.</p> <p>Parameters:</p> Name Type Description Default <code>exclude_root_name</code> <code>bool</code> <p>If true, excludes name of root from the path. Default: False</p> <code>False</code>"},{"location":"reference/#bartiq.PortDirection","title":"PortDirection","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>Class for representing port direction.</p>"},{"location":"reference/#bartiq.Resource","title":"Resource","text":"<p>             Bases: <code>BaseModel</code></p> <p>Resource associated with a routine.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>_Name</code> <p>Name of the resource.</p> <code>type</code> <code>ResourceType</code> <p>Type of the resource.</p> <code>parent</code> <code>Optional[Routine]</code> <p>Routine whose resource this object represents.</p> <code>value</code> <code>AnnotatedValue</code> <p>Value of the resources, either concrete one or a variable.</p>"},{"location":"reference/#bartiq.ResourceType","title":"ResourceType","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>Class for representing types of resources.</p>"},{"location":"reference/#bartiq.Routine","title":"Routine","text":"<p>             Bases: <code>BaseModel</code></p> <p>Subroutine in a quantum program.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>_Name</code> <p>Name of the subroutine.</p> <code>type</code> <code>Optional[str]</code> <p>Type of the subroutine, might be None.</p> <code>ports</code> <code>dict[str, Port]</code> <p>Dictionary mapping port name to corresponding Port object with the same name.</p> <code>parent</code> <code>Optional[Self]</code> <p>A Routine whose this routine is subroutine of. Might be None, in which case the routine is considered to be root of computation.</p> <code>children</code> <code>dict[str, Routine]</code> <p>Dictionary mapping name of subroutine of this routine into routine object with the same name.</p> <code>connections</code> <code>list[Connection]</code> <p>List of connections objects, containing all the directed edges between either ports of this routine and ports of its children or ports of two children. Importantly, by convention, connection objects cannot descend further then one generation (i.e. there might not be a connection between routine and its grandchild).</p> <code>resources</code> <code>dict[str, Resource]</code> <p>Dictionary mapping name of the resource to corresponding Resource object.</p> <code>input_params</code> <code>Sequence[Symbol]</code> <p>Sequence of symbols determining inputs for this routine.</p> <code>local_variables</code> <code>list[str]</code> <p>Convenience aliases to expressions commonly used within this Routine. For instance, for a Routine with input parameter d one of the local variables can be N=ceil(log_2(d)).</p> <code>linked_params</code> <code>dict[Symbol, list[tuple[str, Symbol]]]</code> <p>Dictionary defining relations between parameters of this routine and parameters of its children. This dictionary is keyed with this routine's symbols, with the corresponding values being list of pairs (child, param) to which the symbol is connected to. Unlike connections, parameters links might descend further than one generation.</p> <code>meta</code> <code>Optional[dict[str, Any]]</code> <p>Addictional free-form information associated with this routine.</p>"},{"location":"reference/#bartiq.Routine.input_ports","title":"input_ports  <code>property</code>","text":"<pre><code>input_ports: dict[str, Port]\n</code></pre> <p>Dictionary of input ports of this routine.</p>"},{"location":"reference/#bartiq.Routine.is_leaf","title":"is_leaf  <code>property</code>","text":"<pre><code>is_leaf: bool\n</code></pre> <p>Return True if this routine is a leaf, and false otherwise.</p> <p>By the definition, a routine is a leaf iff it has no children.</p>"},{"location":"reference/#bartiq.Routine.is_root","title":"is_root  <code>property</code>","text":"<pre><code>is_root: bool\n</code></pre> <p>Return True if this routine is a root, and false otherwise.</p> <p>By the definition, a routine is a root iff it doesn't have a parent.</p>"},{"location":"reference/#bartiq.Routine.output_ports","title":"output_ports  <code>property</code>","text":"<pre><code>output_ports: dict[str, Port]\n</code></pre> <p>Dictionary of output ports of this routine.</p>"},{"location":"reference/#bartiq.Routine.absolute_path","title":"absolute_path","text":"<pre><code>absolute_path(exclude_root_name: bool = False) -&gt; str\n</code></pre> <p>Returns a path from root.</p> <p>Parameters:</p> Name Type Description Default <code>exclude_root_name</code> <code>bool</code> <p>If true, excludes name of root from the path. Default: False</p> <code>False</code>"},{"location":"reference/#bartiq.Routine.find_descendant","title":"find_descendant","text":"<pre><code>find_descendant(selector: str) -&gt; Routine\n</code></pre> <p>Given a selector of a child, return the corresponding routine.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>str</code> <p>a string comprising sequence of names determining the child. For instance, a string \"a.b.c\" mean child with name \"c\" of routine with name \"b\", which itself is a child of routine \"a\" which is a child of self. If empty string is provided, returns itself.</p> required <p>Returns:</p> Type Description <code>Routine</code> <p>Routine corresponding to given selector.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if given child is not found.</p>"},{"location":"reference/#bartiq.Routine.relative_path_from","title":"relative_path_from","text":"<pre><code>relative_path_from(\n    ancestor: Optional[Routine],\n    exclude_root_name: bool = False,\n) -&gt; str\n</code></pre> <p>Return relative path to the ancestor.</p> <p>Parameters:</p> Name Type Description Default <code>ancestor</code> <code>Optional[Routine]</code> <p>Ancestor from which a relative path to self should be found.</p> required <code>exclude_root_name</code> <code>bool</code> <p>if True, removes the name of the root from the relative path, if it is present.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>selector s such that ancestor.find_descendant(s) is self.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If ancestor is not, in fact, an ancestor of self.</p>"},{"location":"reference/#bartiq.Routine.walk","title":"walk","text":"<pre><code>walk() -&gt; Iterable[Self]\n</code></pre> <p>Iterates through all the ancestry, deep-first.</p>"},{"location":"reference/#bartiq.compile_routine","title":"compile_routine","text":"<pre><code>compile_routine(\n    routine,\n    *,\n    backend=sympy_backend,\n    precompilation_stages=None,\n    global_functions=None,\n    functions_map=None,\n    skip_verification: bool = False\n)\n</code></pre> <p>Compile estimates for given uncompiled Routine.</p> <p>Parameters:</p> Name Type Description Default <code>routine</code> <p>Routine to be compiled</p> required <code>backend</code> <p>The backend to use for manipulating symbolic expressions. Defaults to sympy_backend.</p> <code>sympy_backend</code> <code>precompilation_stages</code> <p>a list of precompilation stages which should be applied. If <code>None</code>, default precompilation stages are used.</p> <code>None</code> <code>global_functions</code> <p>functions in the cost expressions which we don't want to have namespaced.</p> <code>None</code> <code>functions_map</code> <p>a dictionary which specifies non-standard functions which need to applied during compilation.</p> <code>None</code> <code>skip_verification</code> <code>bool</code> <p>if True, skips routine verification before and after compilation.</p> <code>False</code>"},{"location":"reference/#bartiq.evaluate","title":"evaluate","text":"<pre><code>evaluate(\n    routine,\n    assignments,\n    *,\n    backend=sympy_backend,\n    functions_map=None\n) -&gt; Routine\n</code></pre> <p>Evaluates an estimate of a series of variable assignments.</p> <p>Parameters:</p> Name Type Description Default <code>routine</code> <p>Routine to evaluate. Note: this must have been compiled already.</p> required <code>assignments</code> <p>A list of variable assignments, such as <code>['x = 10', 'y = 3.141']</code>.</p> required <code>backend</code> <p>A backend used for manipulating symbolic expressions.</p> <code>sympy_backend</code> <code>functions_map</code> <p>A dictionary with string keys and callable functions as values. If any of the routines contains a function matching the key in this dict, it will be replaced by calling corresponding value of this dict.</p> <code>None</code> <p>Returns:</p> Type Description <code>Routine</code> <p>A new estimate with variables assigned to the desired values.</p>"},{"location":"reference/#bartiq.precompilation","title":"bartiq.precompilation","text":""},{"location":"reference/#bartiq.precompilation.AddPassthroughPlaceholder","title":"AddPassthroughPlaceholder","text":"<p>Adds placeholder routines whenever passthrough is detected.</p> <p>Contrary to other precompilation methods, this one is stateful (and therefore implemented as a class), to ensure unique name and register size for each passhtrough.</p>"},{"location":"reference/#bartiq.precompilation.AddPassthroughPlaceholder.add_passthrough_placeholders","title":"add_passthrough_placeholders","text":"<pre><code>add_passthrough_placeholders(\n    routine: Routine, _backend: SymbolicBackend\n) -&gt; None\n</code></pre> <p>Detects when a passthrough occurs in given routine and removes it. Passthroughs are problematic for the compilation process and are removed by adding \"identity routines\". This changes the topology of the routine, but it functionally stays the same.</p> <p>NOTE: To work properly it needs to be used before remove_non_root_container_input_register_sizes.</p>"},{"location":"reference/#bartiq.precompilation.add_default_additive_resources","title":"add_default_additive_resources","text":"<pre><code>add_default_additive_resources(\n    routine: Routine, _backend: SymbolicBackend\n) -&gt; None\n</code></pre> <p>Adds an additive resources to routine if any of the children contains them.</p> <p>If given routine: - has children, - children have defined some additive resources - is missing some these resources, it adds the resource which is sum of the resources in subroutines.</p>"},{"location":"reference/#bartiq.precompilation.add_default_properties","title":"add_default_properties","text":"<pre><code>add_default_properties(\n    routine: Routine,\n    _backend: SymbolicBackend,\n    defaults: Optional[DefaultsMap] = None,\n) -&gt; None\n</code></pre> <p>Adds a default resources/port sizes to a routine based on its type.</p>"},{"location":"reference/#bartiq.precompilation.default_precompilation_stages","title":"default_precompilation_stages","text":"<pre><code>default_precompilation_stages()\n</code></pre> <p>Default suite of precompilation stages.</p>"},{"location":"reference/#bartiq.precompilation.precompile","title":"precompile","text":"<pre><code>precompile(\n    routine: Routine,\n    backend: SymbolicBackend,\n    precompilation_stages: Optional[\n        list[PrecompilationStage]\n    ] = None,\n) -&gt; Routine\n</code></pre> <p>A precompilation stage that transforms a routine prior to estimate compilation.</p> <p>If no precompilation stages are specified, the following precompilation stages are performed by default (in order): 1. Adds default resources and register sizes for the following routine types:   - <code>merge</code> 2. Adds additive resources to routines if there's an additive resources in any of the children. 3. Adds \"fake routines\" when passthrough is detected. 4. Removes input register sizes from non-root routines as they will be derived from the connected output ports     in the compilation process. 5. Replaces wildcard statements (\"~\") with appropriate expressions.</p> <p>Parameters:</p> Name Type Description Default <code>routine</code> <code>Routine</code> <p>A uncompiled routine.</p> required <code>backend</code> <code>SymbolicBackend</code> <p>Backend used to perform expression manipulation.</p> required <code>precompilation_stages</code> <code>Optional[list[PrecompilationStage]]</code> <p>A list of functions that modify routine and all it's sub-routines in place.</p> <code>None</code>"},{"location":"reference/#bartiq.precompilation.remove_non_root_container_input_register_sizes","title":"remove_non_root_container_input_register_sizes","text":"<pre><code>remove_non_root_container_input_register_sizes(\n    routine: Routine, _backend: SymbolicBackend\n) -&gt; None\n</code></pre> <p>Removes any non-root container inputer register sizes defined.</p>"},{"location":"reference/#bartiq.precompilation.unroll_wildcarded_resources","title":"unroll_wildcarded_resources","text":"<pre><code>unroll_wildcarded_resources(\n    routine: Routine, backend: SymbolicBackend\n) -&gt; None\n</code></pre> <p>Unrolls wildcarded expressions in the resources using information from its children. Right now it supports only non-nested expressions.</p>"},{"location":"reference/#bartiq.symbolics","title":"bartiq.symbolics","text":""},{"location":"reference/#bartiq.routing","title":"bartiq.routing","text":""},{"location":"reference/#bartiq.routing.get_port_source","title":"get_port_source","text":"<pre><code>get_port_source(port: Port) -&gt; Port\n</code></pre> <p>Finds the port's source port, i.e. the terminal port reached by following upstream connections. It ignores the intermediate ports, like parent's ports, which only facilitate connections through layers of hierarchy, but do not provide meaningful inputs.</p>"},{"location":"reference/#bartiq.routing.get_port_target","title":"get_port_target","text":"<pre><code>get_port_target(port: Port) -&gt; Port\n</code></pre> <p>Finds port's target port, i.e. the terminal port reached by following downstream connections. It ignores the intermediate ports, like parent's ports, which only facilitate connections through layers of hierarchy, but do not provide meaningful inputs.</p>"},{"location":"reference/#bartiq.routing.get_route","title":"get_route","text":"<pre><code>get_route(port: Port, forward: bool = True) -&gt; list[Port]\n</code></pre> <p>Returns a list of all the ports that will be encountered when following particular port in either direction.</p>"},{"location":"reference/#bartiq.routing.join_paths","title":"join_paths","text":"<pre><code>join_paths(*paths: str) -&gt; str\n</code></pre> <p>Helper function for joining paths in a routine.</p>"},{"location":"reference/#bartiq.errors","title":"bartiq.errors","text":""},{"location":"reference/#bartiq.errors.BartiqCompilationError","title":"BartiqCompilationError","text":"<p>             Bases: <code>Exception</code></p> <p>Raised for errors during Bartiq function compilation.</p>"},{"location":"reference/#bartiq.errors.BartiqPrecompilationError","title":"BartiqPrecompilationError","text":"<p>             Bases: <code>Exception</code></p> <p>Raised for errors during Bartiq function pre-compilation.</p>"},{"location":"reference/#bartiq.integrations","title":"bartiq.integrations","text":""},{"location":"reference/#bartiq.integrations.bartiq_to_qref","title":"bartiq_to_qref","text":"<pre><code>bartiq_to_qref(\n    routine: Routine, version: str = \"v1\"\n) -&gt; SchemaV1\n</code></pre> <p>Convert Bartiq routine to QREF object.</p>"},{"location":"reference/#bartiq.integrations.qref_to_bartiq","title":"qref_to_bartiq","text":"<pre><code>qref_to_bartiq(qref_obj: Union[SchemaV1, dict]) -&gt; Routine\n</code></pre> <p>Convert QREF object to a Bartiq routine.</p>"},{"location":"reference/#bartiq.verification","title":"bartiq.verification","text":""},{"location":"reference/#bartiq.verification.VerificationOutput","title":"VerificationOutput  <code>dataclass</code>","text":"<p>Dataclass containing the output of the verification.</p>"},{"location":"reference/#bartiq.verification.VerificationOutput.is_valid","title":"is_valid  <code>property</code>","text":"<pre><code>is_valid\n</code></pre> <p>If true, no issues has been found in the process of verification.</p>"},{"location":"reference/#bartiq.verification.verify_compiled_routine","title":"verify_compiled_routine","text":"<pre><code>verify_compiled_routine(\n    routine: Routine, backend: SymbolicBackend\n) -&gt; VerificationOutput\n</code></pre> <p>Verifies whether a compiled routine has correct format.</p> <p>This function checks:</p> <ul> <li>routine's topology</li> <li>if all the expression contain only parameters defined at the top level</li> <li>if all the linked_params are empty</li> </ul> <p>Parameters:</p> Name Type Description Default <code>routine</code> <code>Routine</code> <p>Routine to be verified.</p> required <code>backend</code> <code>SymbolicBackend</code> <p>Backend used for verification</p> required"},{"location":"reference/#bartiq.verification.verify_routine_topology","title":"verify_routine_topology","text":"<pre><code>verify_routine_topology(\n    routine: Routine,\n) -&gt; VerificationOutput\n</code></pre> <p>Verifies whether the routine has correct topology.</p> <p>It uses QREF's <code>verify_topology</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>routine</code> <code>Routine</code> <p>Routine to be verified.</p> required"},{"location":"reference/#bartiq.verification.verify_uncompiled_routine","title":"verify_uncompiled_routine","text":"<pre><code>verify_uncompiled_routine(\n    routine: Routine, backend: SymbolicBackend\n) -&gt; VerificationOutput\n</code></pre> <p>Verifies whether an uncompiled routine has correct format.</p> <p>This function checks:</p> <ul> <li>routine's topology</li> <li>whether parameter linking is correct</li> <li>if all the expressions in the routine can be parsed by a provided backend</li> </ul> <p>Parameters:</p> Name Type Description Default <code>routine</code> <code>Routine</code> <p>Routine to be verified.</p> required <code>backend</code> <code>SymbolicBackend</code> <p>Backend used for verification</p> required <p>Returns:</p> Type Description <code>VerificationOutput</code> <p>verified stuff</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>Debugging <code>bartiq</code> is not always straightforward, so please see below for a number of best practices and common issues:</p> <ul> <li> <p>Bartiq routines can get pretty complicated very quickly, especially if nested subroutines are involved. Therefore when you get an error, try isolating the issue and work on a smaller example:</p> <ul> <li>First make sure that each child subroutine compiles correctly on its own. If not, this might suggest where the issue is.</li> <li>Try removing all the unnecessary fields, children, connections, etc. and prepare a minimal failing example.</li> </ul> </li> <li> <p>Take a look at the list of issues on GitHub\u00a0\u29c9 and see if other didn't have a similar problem!</p> <ul> <li>If not, consider creating one!</li> <li>Submitting issue is the most transparent way to give us feedback \u2013 even if something works, but is extremely unintuitive, we want to make it easier to use. The goal of this tool is to save you time, not waste it on unhelpful error messages.</li> </ul> </li> <li> <p>If you see a <code>passthrough</code> in your error message, but you don't know where it came from, passthroughs are added automatically during one of the precompilation stages (see precompilation page for more details).</p> </li> </ul>"},{"location":"concepts/compilation/","title":"Compilation","text":"<p>Here we will describe how the compilation process in Bartiq works. Please keep in mind, that while we try to keep this page up-to-date, in the end the code is the only source-of-truth. If you notice any discrepancies, between what's described here and how Bartiq behaves, please create an issue\u00a0\u29c9!</p>"},{"location":"concepts/compilation/#birds-eye-perspective-on-compilation","title":"Bird's eye perspective on compilation","text":"<p>Compilation consists of the following steps:</p> <ol> <li>Precompilation - ensures that Routine has all the components needed for the rest of the compilation process.</li> <li>Routine-to-function conversion \u2013\u00a0maps routine to functions (see glossary), on which compilation is performed.</li> <li>Function compilation \u2013 compiles all the functions to a </li> </ol>"},{"location":"concepts/compilation/#step-1-precompilation","title":"Step 1 \u2013 precompilation","text":"<p>This stage \"precompiles\" the routine by making a series of reasonable assumptions about what the user would have wanted when they have not been explicit. For example, insertion of \"trivial\" routines for known subroutines or \"filling out\" routines which have only been partially defined. It is expected that this precompilation stage will grow as more sensible defaults are requested by users. For more details please visit precompilation page.</p>"},{"location":"concepts/compilation/#step-2-routine-to-function-conversion","title":"Step 2 \u2013\u00a0routine to function conversion","text":"<p>Before being compiled, routines must first be mapped to compilable function objects (see glossary). At this stage, we perform a number of steps to map the routines into functions that are ready for compilation:</p> <ol> <li>Map routines to \"local\" functions: first, we simply map the routines to functions in a local manner, whereby they    are unaware of their location within the full definition. To do this we convert <code>Routine</code> objects to <code>RoutineWithFunction</code>, which augments Routine class with a <code>symbolic_function</code> field.</li> <li>Map \"local\" functions to \"global\" functions: we tell the functions where they live in the definition, thereby    making each parameter and any named functions unique within the definition by prepending it with its full path from the root.</li> <li>Pull in input register sizes: in order to allow for input register sizes to be compiled properly, low-level input    register sizes must be renamed by the size parameters used by high-level registers. This process is referred to as    \"pulling in\" those high-level register sizes.</li> <li>Push out output register sizes: to ensure correct compilation for output register sizes, those associated with    low-level routines must be \"push out\" to either other low-level routines or eventually high-level routines.</li> <li>Parameter inheritance: lastly, any high-level routines parameters are passed down to low-level routines by    substituting the low-level routine parameters with the high-level ones.</li> </ol> <p>Once this is complete, each subroutine has an associated function, which is expressed in terms of global variables.</p>"},{"location":"concepts/compilation/#step-3-functions-compilation","title":"Step 3 \u2013 functions compilation","text":"<p>At the start of this stage routine is annotated with functions which contain all the required information in the global namespace. Compilation starts from the leafs, each routine can only be compiled once all of its children have been compiled (\"bottom-up\"). This stage contains a number of sub-steps:</p> <ol> <li>Compile functions of self and children (non-leaves only): for leaves, no function compilation is necessary, but    non-leaves need to update information in associated function with the information contained in their children's functions.</li> <li>Undo register size pulling and pushing: to ensure a correct local estimate, we must \"undo\" the pulling in and pushing    out of register size params done during routine-to-function conversion.</li> <li>Derefence global namespace: again, to ensure a correct local routine definition, we dereference the global    namespace. This means dropping the path prefix from all the variables: e.g.: <code>root.child.gchild.N</code> would become <code>N</code>.</li> <li>Map function to routine: lastly, once the correct local function has been compiled, we map the function object    back to a routine by updating routine's attribute and removing associated function object.</li> </ol>"},{"location":"concepts/compilation/#glossary","title":"Glossary","text":"<ul> <li>Function: functions are objects defined with <code>SymbolicFunction</code> class. Each function has a defined set of inputs and outputs. Inputs are independent variables, whic are basically bare symbols, without any structure. Outputs are dependent variables, meaning they are variables defined by expressions which are dependent on the input variables.</li> <li>Global and local: in this context \"global\" means \"defined at the root-level of the routine we compile\". Local, on the contrary, means \"defined for the subroutine currently being operated on\". Intuitively, global parameters are those that correspond to the domain of the problem that we are trying to solve, e.g.: number of bits of precision of QPE. On the other hand, local parameters correspond to the implementation details of the algorithm we are analyzing, e.g.: size of the QFT routine in QPE. Compilation process allows us to express all the local parameters in the algorithm in terms of the global parameters.</li> </ul>"},{"location":"concepts/data_format/","title":"Data format","text":""},{"location":"concepts/evaluation/","title":"Evaluation","text":""},{"location":"concepts/precompilation/","title":"Precompilation","text":"<p>Precompilation is a collection of steps we perform prior to the proper compilation. They apply a series of reasonable assumptions about what the user would have wanted when they have not been explicit in defining their routine.</p>"},{"location":"concepts/precompilation/#usage","title":"Usage","text":"<p>By default precompilation is performed in the <code>compile_routine</code> method with a set of default stages. However, API for precompilation has been designed to make customizing precompilation stages easy. </p> <p>First, user can define their own precompilation stages. All precompilation stages have the same interface \u2013 as inputs they take <code>Routine</code> and <code>SymbolicBackend</code> and they modify the provided <code>Routine</code> object in place. Therefore adding a custom stage requires simply writing a method which complies with this interface.</p> <p>Second, the choice and order of the stages used can be changed by passing them explicitly through <code>precompilation_stages</code> argument of the <code>compile_routine</code> method.</p> <p>Precompilation can also be performed outside of the <code>compile_routine</code> by using <code>precompile</code> method. </p>"},{"location":"concepts/precompilation/#precompilation-stages","title":"Precompilation stages","text":"<p><code>bartiq.precompilation</code> module currently contains the stages listed below. They are applied by default in the order provided.</p> <ol> <li> <p>Add default properties: adds default properties for the subroutines of certain type. Right now it only acts on the routines of type <code>merge</code>. If the size of the output port is not specified, it sets it to the sume of the sizes of the input ports.</p> </li> <li> <p>Add default additive resources: if the user defined resource of type <code>additive</code> anywhere in any of the subroutines, it implies that this resource should be included in their parent as a sum of the resources of their children. An example of an additive resource is T gate \u2013\u00a0if a routine contains two children A and B, which have resource <code>T</code> defined, equal to <code>N_A</code> and <code>N_B</code>, after performing this stage, the parent will also have resource <code>T</code> with the value equal to <code>N_A + N_B</code>.</p> </li> <li> <p>Add passthrough placeholder: passthrough is a situation where we have a routine, which has a connection that goes straight from the input to output port, without touching any subroutines on its way. Currently Bartiq can't handle such cases in the compilation process and in order to get around in the precompilation process we add a \"virtual\" routine of type <code>passthrough</code>, which is not associated with any real operation (it can be thought of as an \"identity gate\"), but which removes the passthrough from the topology of the routine.</p> </li> <li> <p>Removing non-root non-leaf input register sizes: currently Bartiq cannot handle situation where port get a size assigned twice. For example, the first assigned comes from how the port is defined and the second comes from the connection (i.e. we derive the size of the port based on the fact that we know the size of the port on the other side of the connection). In order to alleviate this issue, in this precompilation step we set to <code>None</code> sizes of the input ports of all the routines which are neither root nor leaf.</p> </li> <li> <p>Unroll wildcarded resources: if wildcard symbol (<code>~</code>) is detected in the resource, it gets replaced with the proper expression. An example usage would be when a routine has multiple children and we only want to add the resources of the children with the name fitting certain pattern, e.g.: <code>cost = sum(select_~.cost)</code> would only add <code>cost</code> for the children whose names start with <code>select_</code> and that have <code>cost</code> resource defined.</p> </li> </ol>"},{"location":"concepts/symbolics/","title":"Symbolics","text":""},{"location":"tutorials/","title":"Introduction","text":"<p>We currently have two tutorials for <code>bartiq</code>:</p> <ul> <li>Basic example</li> <li>Alias Sampling basic</li> </ul> <p>They have been designed to gradually introduce you to the concepts we use in <code>bartiq</code>, so we recommend to go through them in order.</p>"},{"location":"tutorials/01_basic_example/","title":"Basic example","text":"<p>In this tutorial our goals are to learn:</p> <ul> <li>How to use <code>bartiq</code> to implement a quantum algorithm from a paper.</li> <li>How to obtain resource estimates for that algorithm.</li> <li>What the most important concepts used in <code>bartiq</code> are.</li> </ul> <p>NOTE:</p> <p>This tutorial, as well as all the other tutorials, has been written as a jupyter notebook. If you're reading it online, you can either keep reading, or go to <code>docs/tutorials</code> to explore them in a more interactive way!</p> <p>Before we start implementing some real algorithms, let's consider the following simple routine:</p> <p></p> <p>In <code>bartiq</code> we call our main object <code>Routine</code> \u2013 both the whole algorithm here, as well as each operation will be a <code>Routine</code>. So what do we know about the routines from the picture above?</p> <ul> <li>Our main routine is called \"my algorithm\"</li> <li>It consists of two subroutines: \"A\" and \"B\".</li> <li>It takes in a register of size \"n\".</li> </ul> <p>How do we express this in <code>bartiq</code>? We do that using the <code>QREF</code> format\u00a0\u29c9 \u2013 a format for expressing algorithms that we developed with QREs in mind. So let's write our first routine:</p> In\u00a0[31]: Copied! <pre>my_algorithm = {\n    \"name\": \"my_algorithm\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"in\", \"direction\": \"input\", \"size\": \"n\"},\n        {\"name\": \"out\", \"direction\": \"output\", \"size\": None},\n    ],\n}\n</pre> my_algorithm = {     \"name\": \"my_algorithm\",     \"type\": None,     \"ports\": [         {\"name\": \"in\", \"direction\": \"input\", \"size\": \"n\"},         {\"name\": \"out\", \"direction\": \"output\", \"size\": None},     ], } <p>What do we have here?</p> <ul> <li><code>name</code>: name of the routine</li> <li><code>type</code>: in this case we don't define the type, but in more complex algorithms you might want to add types, such as \"basic_gate\" or \"comparator\".</li> <li><code>ports</code>: ports define the interface of the routine. The size of the input port is equal to <code>n</code> and in general, we won't know the size of the output port until we perform the compilation.</li> </ul> <p>What are we missing? Children.</p> <p>Before we add them to the main routine we need to define them though.</p> In\u00a0[32]: Copied! <pre>routine_a = {\n    \"name\": \"A\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"in\", \"direction\": \"input\", \"size\": \"n_a\"},\n        {\"name\": \"out\", \"direction\": \"output\", \"size\": \"2*n_a\"},\n    ],\n}\n</pre> routine_a = {     \"name\": \"A\",     \"type\": None,     \"ports\": [         {\"name\": \"in\", \"direction\": \"input\", \"size\": \"n_a\"},         {\"name\": \"out\", \"direction\": \"output\", \"size\": \"2*n_a\"},     ], } <p>Notice, that the sizes of input and output ports don't need to match. Here we defined that the size of the output port is twice the size of the input.</p> In\u00a0[33]: Copied! <pre>routine_b = {\n    \"name\": \"B\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"in\", \"direction\": \"input\", \"size\": \"n_b\"},\n        # \"y\" will be defined in the next step\n        {\"name\": \"out\", \"direction\": \"output\", \"size\": \"n_b + y\"},\n    ],\n}\n</pre> routine_b = {     \"name\": \"B\",     \"type\": None,     \"ports\": [         {\"name\": \"in\", \"direction\": \"input\", \"size\": \"n_b\"},         # \"y\" will be defined in the next step         {\"name\": \"out\", \"direction\": \"output\", \"size\": \"n_b + y\"},     ], } <p>We will need to know how much each subroutine costs if we want to run the resource estimation. In fault-tolerant quantum computation a common metric of interest is an algorithm's T-gate count. (T-gates are a particular quantum gate which are typically more expensive to implement than other quantum gates, and so are commonly used as the standard metric for an algorithm's computational cost.)</p> <p>In this example, let's say that routine <code>A</code> costs <code>2*n_a + x</code> T gates and routine <code>B</code> costs <code>n_b*ceil(log_2(n_b)) * y</code> T-gates, where <code>x</code> and <code>y</code> are some arbitrary paremeters.</p> <p>Knowing T-gate costs and sizes of parameters, we can now visualize subroutines <code>A</code> and <code>B</code> like this:</p> <p></p> <p>This will require adding two new fields to the dictionaries defining <code>A</code> and <code>B</code> respectively:</p> In\u00a0[34]: Copied! <pre># Define T-gate counts for routine a\nroutine_a[\"input_params\"] = [\"x\"]\nroutine_a[\"resources\"] = [{\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"2*n_a + x\"}]\n\n# Define T-gate counts for routine b\nroutine_b[\"input_params\"] = [\"y\"]\nroutine_b[\"resources\"] = [{\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"n_b*ceil(log_2(n_b)) * y\"}]\n</pre> # Define T-gate counts for routine a routine_a[\"input_params\"] = [\"x\"] routine_a[\"resources\"] = [{\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"2*n_a + x\"}]  # Define T-gate counts for routine b routine_b[\"input_params\"] = [\"y\"] routine_b[\"resources\"] = [{\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"n_b*ceil(log_2(n_b)) * y\"}] <p>As you can see we added two new fields to our dictionaries:</p> <ul> <li><code>input_params</code>: which defines the variables used by the routine's resource expressions.</li> <li><code>resources</code>: which defines the resource costs for our routine. As you can see resources have the following fields:<ul> <li><code>name</code>: name of the resource</li> <li><code>type</code>: <code>bartiq</code> allows for the following types: <code>additive</code>, <code>multiplicative</code>, <code>qubits</code> and <code>other</code>.</li> <li><code>value</code>: expression (or numeric value) defining the cost.</li> </ul> </li> </ul> <p>Now that <code>routine_a</code> and <code>routine_b</code> are complete, we can add the missing components to <code>my_algorithm</code>:</p> In\u00a0[35]: Copied! <pre>my_algorithm[\"children\"] = [routine_a, routine_b]\nmy_algorithm[\"connections\"] = [\n    {\"source\": \"in\", \"target\": \"A.in\"},\n    {\"source\": \"A.out\", \"target\": \"B.in\"},\n    {\"source\": \"B.out\", \"target\": \"out\"},\n]\nmy_algorithm[\"input_params\"] = [\"z\"]\nmy_algorithm[\"linked_params\"] = [{\"source\": \"z\", \"targets\": [\"A.x\", \"B.y\"]}]\n</pre> my_algorithm[\"children\"] = [routine_a, routine_b] my_algorithm[\"connections\"] = [     {\"source\": \"in\", \"target\": \"A.in\"},     {\"source\": \"A.out\", \"target\": \"B.in\"},     {\"source\": \"B.out\", \"target\": \"out\"}, ] my_algorithm[\"input_params\"] = [\"z\"] my_algorithm[\"linked_params\"] = [{\"source\": \"z\", \"targets\": [\"A.x\", \"B.y\"]}] <p>The new things we have here are:</p> <ul> <li><code>connections</code>: defines how routines are connected via their ports. Each connection has source and target.</li> <li><code>children</code>: defines a routine's subroutines.</li> <li><code>linked_params</code>: defines how input parameters used by the parent are linked to the parameters of children. In this case, it specifies that the input parameter <code>z</code> should be passed as <code>x</code> to the subroutine <code>A</code> and as <code>y</code> to <code>B</code>. Note that we don't need to pass information about <code>n</code>, <code>n_a</code> and <code>n_b</code>, as this information gets passed through the connections.</li> </ul> <p>The last step is just a formality to indicate which version of QREF schema we use:</p> In\u00a0[36]: Copied! <pre>my_algorithm_qref = {\"version\": \"v1\", \"program\": my_algorithm}\n</pre> my_algorithm_qref = {\"version\": \"v1\", \"program\": my_algorithm} <p>So, is there an intuitive way to understand what my algorithm looks like and how the resources are used in each routine? You can use the visualization tool from <code>QREF</code>\u00a0\u29c9 to plot the hierarchical Directed Acyclic Graph (DAG) of the algorithm you wrote.</p> <p>NOTE:</p> <p>         To use the qref\u00a0\u29c9 rendering tool in Jupyter Notebook, ensure the Graphviz software is installed on your OS and that its executables are included in your system variables. For installation instructions, please refer to the Graphviz download page\u00a0\u29c9.     </p> <p>Then, run: </p> In\u00a0[37]: Copied! <pre>from qref.experimental.rendering import to_graphviz\n\n# Convert the qref format to Graphviz object\ngv_object = to_graphviz(my_algorithm_qref)\n\n# Render the Graphviz object to a PNG file\ngv_object.render(\"my_algorithm\", format=\"png\")\n\n# Render the Graphviz object in the notebook\ngv_object\n</pre> from qref.experimental.rendering import to_graphviz  # Convert the qref format to Graphviz object gv_object = to_graphviz(my_algorithm_qref)  # Render the Graphviz object to a PNG file gv_object.render(\"my_algorithm\", format=\"png\")  # Render the Graphviz object in the notebook gv_object Out[37]: <p>From this graph, you can find both subroutines from the original algorithm, along with their <code>name</code>, and<code>ports</code>. It provides a general idea of the connectivity between subroutines in the algorithm and shows how information is stored.</p> <p>Now we can translate our algorithm into a proper <code>bartiq</code> routine and see what's the total cost of <code>my_algorithm</code>.</p> <p>Below you can find depiction of <code>my_algorithm</code>. </p> <p>We can create <code>bartiq</code> <code>Routine</code> from <code>QREF</code> definition by simply running:</p> In\u00a0[38]: Copied! <pre>from bartiq.integrations import qref_to_bartiq\n\nuncompiled_routine = qref_to_bartiq(my_algorithm_qref)\n</pre> from bartiq.integrations import qref_to_bartiq  uncompiled_routine = qref_to_bartiq(my_algorithm_qref) <p>What does \"uncompiled\" means here?</p> <p>It means that all the costs and register sizes are expressed using local variables (as in the picture above). What does it mean? Look at this:</p> In\u00a0[39]: Copied! <pre>uncompiled_routine.children[\"A\"].resources\n</pre> uncompiled_routine.children[\"A\"].resources Out[39]: <pre>{'T_gates': &lt;Resource name=\"T_gates\" value=\"2*n_a + x\"&gt;}</pre> <p>The cost of <code>A</code> is still expressed in terms of its own \"local\" variables, <code>n_a</code> and <code>x</code>. Information that we included in <code>linked_params</code> has not yet been propagated into <code>A</code>.</p> <p>We also don't know yet what's the size of the output port:</p> In\u00a0[40]: Copied! <pre>uncompiled_routine.ports[\"out\"]\n</pre> uncompiled_routine.ports[\"out\"] Out[40]: <pre>Port(my_algorithm.#out, size=None, output)</pre> <p>Most importantly, we don't know what is the total cost of the algorithm:</p> In\u00a0[41]: Copied! <pre>uncompiled_routine.resources\n</pre> uncompiled_routine.resources Out[41]: <pre>{}</pre> <p>So what we want to do, is to get to the following picture: </p> <p>You can compare it with the previous picture and see how \"local\" variables have been replaced with \"global\" ones.</p> <p>We do this with the following command:</p> In\u00a0[42]: Copied! <pre>from bartiq import compile_routine\n\ncompiled_routine = compile_routine(uncompiled_routine)\n</pre> from bartiq import compile_routine  compiled_routine = compile_routine(uncompiled_routine) <p>Now let's check the same fields of our <code>compiled_routine</code> object:</p> In\u00a0[43]: Copied! <pre>print(\"T gates for A:\", compiled_routine.children[\"A\"].resources[\"T_gates\"].value)\nprint(\"Output size:\", compiled_routine.ports[\"out\"].size)\nprint(\"Total T gates:\", compiled_routine.resources[\"T_gates\"].value)\n</pre> print(\"T gates for A:\", compiled_routine.children[\"A\"].resources[\"T_gates\"].value) print(\"Output size:\", compiled_routine.ports[\"out\"].size) print(\"Total T gates:\", compiled_routine.resources[\"T_gates\"].value) <pre>T gates for A: 2*n + z\nOutput size: 2*n + z\nTotal T gates: 2*n*z*ceiling(log2(2*n)) + 2*n + z\n</pre> <p>Since the resources in the children have type <code>additive</code>, <code>bartiq</code> automatically added the <code>T_gates</code> resource to the parent as a sum of the resources of the children.</p> <p>Now it would be good to know what is the cost when we subsitute some numbers. We can do this using <code>evaluate</code> method. As you can see in the example below, it can either take all the parameters or just some of them.</p> In\u00a0[44]: Copied! <pre>from bartiq import evaluate\n\nprint(\"Different values of n:\")\nfor n in range(6, 16, 2):\n    assignments = [f\"n={n}\"]\n    evaluated_routine = evaluate(compiled_routine, assignments)\n    print(f\"n = {n}, total T gates:\", evaluated_routine.resources[\"T_gates\"].value)\n\nz = 5\nassignments = [f\"n={n}\", f\"z={z}\"]\nevaluated_routine = evaluate(compiled_routine, assignments)\nprint(f\"For n={n}, z={z}\")\n\nprint(\"Total T gates:\", evaluated_routine.resources[\"T_gates\"].value)\n</pre> from bartiq import evaluate  print(\"Different values of n:\") for n in range(6, 16, 2):     assignments = [f\"n={n}\"]     evaluated_routine = evaluate(compiled_routine, assignments)     print(f\"n = {n}, total T gates:\", evaluated_routine.resources[\"T_gates\"].value)  z = 5 assignments = [f\"n={n}\", f\"z={z}\"] evaluated_routine = evaluate(compiled_routine, assignments) print(f\"For n={n}, z={z}\")  print(\"Total T gates:\", evaluated_routine.resources[\"T_gates\"].value) <pre>Different values of n:\nn = 6, total T gates: 49*z + 12\nn = 8, total T gates: 65*z + 16\nn = 10, total T gates: 101*z + 20\nn = 12, total T gates: 121*z + 24\nn = 14, total T gates: 141*z + 28\nFor n=14, z=5\nTotal T gates: 733\n</pre>"},{"location":"tutorials/01_basic_example/#basic-example","title":"Basic example\u00b6","text":""},{"location":"tutorials/01_basic_example/#compilation","title":"Compilation\u00b6","text":""},{"location":"tutorials/01_basic_example/#evaluation","title":"Evaluation\u00b6","text":""},{"location":"tutorials/01_basic_example/#summary","title":"Summary\u00b6","text":"<p>Let's sum up what we covered in this tutorial:</p> <ul> <li>How to construct a simple algorithm in <code>bartiq</code></li> <li>How to compile an estimate</li> <li>How to evaluate an estimate</li> <li>How to use the <code>qref</code> visualization tool to visualize an algorithm</li> </ul> <p>In the next tutorial we'll cover how to implement a more complex algorithm from a paper.</p>"},{"location":"tutorials/02_alias_sampling_basic/","title":"Alias Sampling","text":"<p>NOTE:</p> <p>This tutorial, as well as all the other tutorials, has been written as a jupyter notebook. If you're reading it online, you can either keep reading, or clone the repository and go to <code>docs/tutorials</code> to explore them in a more interactive way!</p> <p>The example we used in previous tutorial was nice to establish some basic terminology. But let's be honest, it was contrived and not very practical. So now we'll take an existing example from a paper and try to get some resource estimations for it using <code>bartiq</code>!</p> <p>For that we'll use Alias Sampling\u2014an algorithm proposed by Babbush et al. in Encoding Electronic Spectra in Quantum Circuits with Linear T Complexity\u00a0\u29c9. This is what the circuit looks like:</p> <p></p> <p>It comes from Fig. 11 from the original paper.</p> <p>This circuit is an important subroutine in the paper's larger algorithm because it is responsible for preparing arbitrary quantum states, which can be thought of as \"loading\" data into the quantum computer.</p> <p>In this tutorial we won't be explaining how the algorithm works in details\u2014partly because this is not the place, and partly because Craig Gidney already did it in his blogpost\u00a0\u29c9</p> <p>But briefly and at a high level, Alias Sampling contains the following subroutines:</p> <ul> <li>$\\textrm{UNIFORM}_L$:\u00a0prepares a state which is a uniform superposition over $L$ basis states</li> <li>$H^{\\otimes\\mu}$: applies a set of Hadamard gates to create a uniform superposition over $2^{\\mu}$ basis states</li> <li>QROM: loads data values into two \"data\" registers in superposition depending on the state input to $\\textrm{In}_{\\ell}$</li> <li>Comparator:\u00a0flips a target qubit if $\\textrm{keep}_l \\leq \\sigma_l$ based on the values of the two other input registers (to $\\textrm{In}_{\\sigma_l}$ and $\\textrm{In}_{\\textrm{keep}_l}$ respectively).</li> <li>Controlled SWAP: swaps two target registers conditional on the value of a control qubit.</li> </ul> <p>Now, before we map all these subroutines to <code>bartiq</code>, it would be good to know what the costs of each of the subroutines are. After carefully reading the paper we can deduce what the costs are. But before we get there, let's define our symbols to have consistent naming.  The authors use same letters for different variables in different figures, so it can get confusing without reading the paper carefully\u2014that's why we'll stick to the naming from the figure above to keep things simple.</p> <ul> <li>$L$ \u2013\u00a0number of coefficients we want to load.</li> <li>$\\mu$ \u2013 bits of precision for coefficients we load.</li> <li>$k$ is the greatest common factor of $L$. This is not a widely-used mathematical operation, but fortunately in <code>bartiq</code> we have a shorthand for that, and we can say that <code>k = multiplicity(2, L)</code>. For more information, you can check how it's defined in sympy\u00a0\u29c9.</li> </ul> <p>Given all that\u2014what are the costs of our routines? For the purpose of we shall focus on just calculating the T-gate and rotation costs:</p> <ul> <li>Uniform: $8\\log_2(L/k)$ T-gates and 2 rotation gates. It comes Fig 12 and its caption. We omit the $O(\\log(1/\\epsilon)$ term, because it corresponds to those two rotations that we count separately.</li> <li>Hadamards: No T-gates or rotations.</li> <li>QROM: $4L-4$ \u2013 this comes from Fig. 10.</li> <li>Comparator: $4\\mu-4$ \u2013\u00a0this is not stated explicitly in the text, but comes from a careful analysis of the caption of Fig. 11.</li> <li>Swap: $O(\\log_2(L))$ \u2013 this is not stated explicitly in the text, but comes from a careful analysis of the caption of Fig. 11.</li> </ul> <p>These expressions don't take into account some nuances\u2014for example the uniform state preparation (USP) can be implemented as a layer of Hadamard gates if $L$ is a power of two.</p> <p>Armed with this knowledge, we can now write each individual routine. However, since in this case all the routines have similar structure, we can use the following helper function:</p> <p>NOTE:</p> <p>Unfortunately the costs presented in this example are quite complicated. It would be great to just point you to a single place in the paper, get an expression and type it into <code>bartiq</code>. That's not the case though and if there are any mistakes or oversimplifications\u2014please let us know! However, the fact that even a relatively simple routine presents such challenges, shows that we need better tools for working with quantum algorithms.</p> <p>Also, as it turns out in the follow-up work not all the costs from this paper are correct, as some routines can be optimized. But explaining that is way beyond the scope of this tutorial.</p> In\u00a0[41]: Copied! <pre>usp_dict = {\n    \"name\": \"usp\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"in\", \"direction\": \"input\", \"size\": \"R\"},\n        {\"name\": \"out\", \"direction\": \"output\", \"size\": \"R\"},\n    ],\n    \"resources\": [\n        {\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"8*L/multiplicity(2,L)\"},\n        {\"name\": \"rotations\", \"type\": \"additive\", \"value\": \"2\"},\n    ],\n    \"input_params\": [\"L\"],\n    \"local_variables\": [\"R=ceiling(log_2(L))\"],\n}\n</pre> usp_dict = {     \"name\": \"usp\",     \"type\": None,     \"ports\": [         {\"name\": \"in\", \"direction\": \"input\", \"size\": \"R\"},         {\"name\": \"out\", \"direction\": \"output\", \"size\": \"R\"},     ],     \"resources\": [         {\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"8*L/multiplicity(2,L)\"},         {\"name\": \"rotations\", \"type\": \"additive\", \"value\": \"2\"},     ],     \"input_params\": [\"L\"],     \"local_variables\": [\"R=ceiling(log_2(L))\"], } <p>There are two things that we did here which might not be straight-forward.</p> <ul> <li>We used <code>ceiling</code> function for the port size\u2014that's because port sizes need to be integer.</li> <li>We introduced new field: <code>local_variables</code>. This allows us to define some \"helper\" variables, which are only used in the scope of this routine and save us some typing</li> </ul> In\u00a0[42]: Copied! <pre>had_dict = {\n    \"name\": \"had\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"in\", \"direction\": \"input\", \"size\": \"N\"},\n        {\"name\": \"out\", \"direction\": \"output\", \"size\": \"N\"},\n    ],\n}\n</pre> had_dict = {     \"name\": \"had\",     \"type\": None,     \"ports\": [         {\"name\": \"in\", \"direction\": \"input\", \"size\": \"N\"},         {\"name\": \"out\", \"direction\": \"output\", \"size\": \"N\"},     ], } In\u00a0[43]: Copied! <pre>qrom_dict = {\n    \"name\": \"qrom\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"In_l\", \"direction\": \"input\", \"size\": \"R\"},\n        {\"name\": \"In_alt\", \"direction\": \"input\", \"size\": \"R\"},\n        {\"name\": \"In_keep\", \"direction\": \"input\", \"size\": \"mu\"},\n        {\"name\": \"out_l\", \"direction\": \"output\", \"size\": \"R\"},\n        {\"name\": \"out_alt\", \"direction\": \"output\", \"size\": \"R\"},\n        {\"name\": \"out_keep\", \"direction\": \"output\", \"size\": \"mu\"},\n    ],\n    \"resources\": [{\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"4*L-4\"}],\n    \"input_params\": [\"L\", \"mu\"],\n    \"local_variables\": [\"R=ceiling(log_2(L))\"],\n}\n</pre> qrom_dict = {     \"name\": \"qrom\",     \"type\": None,     \"ports\": [         {\"name\": \"In_l\", \"direction\": \"input\", \"size\": \"R\"},         {\"name\": \"In_alt\", \"direction\": \"input\", \"size\": \"R\"},         {\"name\": \"In_keep\", \"direction\": \"input\", \"size\": \"mu\"},         {\"name\": \"out_l\", \"direction\": \"output\", \"size\": \"R\"},         {\"name\": \"out_alt\", \"direction\": \"output\", \"size\": \"R\"},         {\"name\": \"out_keep\", \"direction\": \"output\", \"size\": \"mu\"},     ],     \"resources\": [{\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"4*L-4\"}],     \"input_params\": [\"L\", \"mu\"],     \"local_variables\": [\"R=ceiling(log_2(L))\"], } In\u00a0[44]: Copied! <pre>compare_dict = {\n    \"name\": \"compare\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"In_sigma\", \"direction\": \"input\", \"size\": \"mu\"},\n        {\"name\": \"In_keep\", \"direction\": \"input\", \"size\": \"mu\"},\n        {\"name\": \"In_flag\", \"direction\": \"input\", \"size\": \"1\"},\n        {\"name\": \"out_sigma\", \"direction\": \"output\", \"size\": \"mu\"},\n        {\"name\": \"out_keep\", \"direction\": \"output\", \"size\": \"mu\"},\n        {\"name\": \"out_flag\", \"direction\": \"output\", \"size\": \"1\"},\n    ],\n    \"resources\": [{\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"4*mu-4\"}],\n    \"input_params\": [\"mu\"],\n}\n</pre> compare_dict = {     \"name\": \"compare\",     \"type\": None,     \"ports\": [         {\"name\": \"In_sigma\", \"direction\": \"input\", \"size\": \"mu\"},         {\"name\": \"In_keep\", \"direction\": \"input\", \"size\": \"mu\"},         {\"name\": \"In_flag\", \"direction\": \"input\", \"size\": \"1\"},         {\"name\": \"out_sigma\", \"direction\": \"output\", \"size\": \"mu\"},         {\"name\": \"out_keep\", \"direction\": \"output\", \"size\": \"mu\"},         {\"name\": \"out_flag\", \"direction\": \"output\", \"size\": \"1\"},     ],     \"resources\": [{\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"4*mu-4\"}],     \"input_params\": [\"mu\"], } In\u00a0[45]: Copied! <pre>swap_dict = {\n    \"name\": \"swap\",\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"In_control\", \"direction\": \"input\", \"size\": \"1\"},\n        {\"name\": \"In_target_0\", \"direction\": \"input\", \"size\": \"X\"},\n        {\"name\": \"In_target_1\", \"direction\": \"input\", \"size\": \"X\"},\n        {\"name\": \"out_control\", \"direction\": \"output\", \"size\": None},\n        {\"name\": \"out_target_0\", \"direction\": \"output\", \"size\": None},\n        {\"name\": \"out_target_1\", \"direction\": \"output\", \"size\": None},\n    ],\n    \"resources\": [{\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"O(log_2(X))\"}],\n    \"connections\": [\n        {\"source\": \"In_control\", \"target\": \"out_control\"},\n        {\"source\": \"In_target_0\", \"target\": \"out_target_0\"},\n        {\"source\": \"In_target_1\", \"target\": \"out_target_1\"},\n    ],\n    \"input_params\": [\"X\"],\n}\n</pre> swap_dict = {     \"name\": \"swap\",     \"type\": None,     \"ports\": [         {\"name\": \"In_control\", \"direction\": \"input\", \"size\": \"1\"},         {\"name\": \"In_target_0\", \"direction\": \"input\", \"size\": \"X\"},         {\"name\": \"In_target_1\", \"direction\": \"input\", \"size\": \"X\"},         {\"name\": \"out_control\", \"direction\": \"output\", \"size\": None},         {\"name\": \"out_target_0\", \"direction\": \"output\", \"size\": None},         {\"name\": \"out_target_1\", \"direction\": \"output\", \"size\": None},     ],     \"resources\": [{\"name\": \"T_gates\", \"type\": \"additive\", \"value\": \"O(log_2(X))\"}],     \"connections\": [         {\"source\": \"In_control\", \"target\": \"out_control\"},         {\"source\": \"In_target_0\", \"target\": \"out_target_0\"},         {\"source\": \"In_target_1\", \"target\": \"out_target_1\"},     ],     \"input_params\": [\"X\"], } <p>We follow the same naming convention in all the subroutines to make things easier to follow. But in swap, we decided to use <code>X</code> instead of <code>R=ceil(log_2(L))</code>. Why?</p> <p>It shows, that we can use whatever naming we want for any particular subroutine \u2013 we don't need to stick to one convention in all the subroutines. This is what you would often want to do in practice. If you would like to reuse this controlled swap in some other algorithm, a generic <code>X</code> is a much better choice than a very specific <code>R</code>.</p> <p>Now that we have all these defined, let's construct the dictionary for the whole algorithm:</p> In\u00a0[46]: Copied! <pre>alias_sampling_dict = {\n    \"name\": \"alias_sampling\",\n    \"children\": [usp_dict, had_dict, qrom_dict, compare_dict, swap_dict],\n    \"type\": None,\n    \"ports\": [\n        {\"name\": \"In_0\", \"direction\": \"input\", \"size\": \"R\"},\n        {\"name\": \"In_1\", \"direction\": \"input\", \"size\": \"mu\"},\n        {\"name\": \"In_2\", \"direction\": \"input\", \"size\": \"R\"},\n        {\"name\": \"In_3\", \"direction\": \"input\", \"size\": \"mu\"},\n        {\"name\": \"In_4\", \"direction\": \"input\", \"size\": \"1\"},\n        {\"name\": \"out_0\", \"direction\": \"output\", \"size\": None},\n        {\"name\": \"temp_0\", \"direction\": \"output\", \"size\": None},\n        {\"name\": \"temp_1\", \"direction\": \"output\", \"size\": None},\n        {\"name\": \"temp_2\", \"direction\": \"output\", \"size\": None},\n        {\"name\": \"temp_3\", \"direction\": \"output\", \"size\": None},\n    ],\n    \"connections\": [\n        {\"source\": \"In_0\", \"target\": \"usp.in\"},\n        {\"source\": \"In_1\", \"target\": \"had.in\"},\n        {\"source\": \"In_2\", \"target\": \"qrom.In_alt\"},\n        {\"source\": \"In_3\", \"target\": \"qrom.In_keep\"},\n        {\"source\": \"In_4\", \"target\": \"compare.In_flag\"},\n        {\"source\": \"usp.out\", \"target\": \"qrom.In_l\"},\n        {\"source\": \"had.out\", \"target\": \"compare.In_sigma\"},\n        {\"source\": \"qrom.out_l\", \"target\": \"swap.In_target_0\"},\n        {\"source\": \"qrom.out_alt\", \"target\": \"swap.In_target_1\"},\n        {\"source\": \"qrom.out_keep\", \"target\": \"compare.In_keep\"},\n        {\"source\": \"compare.out_flag\", \"target\": \"swap.In_control\"},\n        {\"source\": \"swap.out_target_0\", \"target\": \"out_0\"},\n        {\"source\": \"compare.out_sigma\", \"target\": \"temp_0\"},\n        {\"source\": \"swap.out_target_1\", \"target\": \"temp_1\"},\n        {\"source\": \"compare.out_keep\", \"target\": \"temp_2\"},\n        {\"source\": \"swap.out_control\", \"target\": \"temp_3\"},\n    ],\n    \"input_params\": [\"mu\", \"L\"],\n    \"local_variables\": [\"R=ceiling(log_2(L))\"],\n    \"linked_params\": [\n        {\"source\": \"L\", \"targets\": [\"usp.L\", \"qrom.L\", \"swap.X\"]},\n        {\"source\": \"mu\", \"targets\": [\"qrom.mu\", \"compare.mu\"]},\n    ],\n}\n</pre> alias_sampling_dict = {     \"name\": \"alias_sampling\",     \"children\": [usp_dict, had_dict, qrom_dict, compare_dict, swap_dict],     \"type\": None,     \"ports\": [         {\"name\": \"In_0\", \"direction\": \"input\", \"size\": \"R\"},         {\"name\": \"In_1\", \"direction\": \"input\", \"size\": \"mu\"},         {\"name\": \"In_2\", \"direction\": \"input\", \"size\": \"R\"},         {\"name\": \"In_3\", \"direction\": \"input\", \"size\": \"mu\"},         {\"name\": \"In_4\", \"direction\": \"input\", \"size\": \"1\"},         {\"name\": \"out_0\", \"direction\": \"output\", \"size\": None},         {\"name\": \"temp_0\", \"direction\": \"output\", \"size\": None},         {\"name\": \"temp_1\", \"direction\": \"output\", \"size\": None},         {\"name\": \"temp_2\", \"direction\": \"output\", \"size\": None},         {\"name\": \"temp_3\", \"direction\": \"output\", \"size\": None},     ],     \"connections\": [         {\"source\": \"In_0\", \"target\": \"usp.in\"},         {\"source\": \"In_1\", \"target\": \"had.in\"},         {\"source\": \"In_2\", \"target\": \"qrom.In_alt\"},         {\"source\": \"In_3\", \"target\": \"qrom.In_keep\"},         {\"source\": \"In_4\", \"target\": \"compare.In_flag\"},         {\"source\": \"usp.out\", \"target\": \"qrom.In_l\"},         {\"source\": \"had.out\", \"target\": \"compare.In_sigma\"},         {\"source\": \"qrom.out_l\", \"target\": \"swap.In_target_0\"},         {\"source\": \"qrom.out_alt\", \"target\": \"swap.In_target_1\"},         {\"source\": \"qrom.out_keep\", \"target\": \"compare.In_keep\"},         {\"source\": \"compare.out_flag\", \"target\": \"swap.In_control\"},         {\"source\": \"swap.out_target_0\", \"target\": \"out_0\"},         {\"source\": \"compare.out_sigma\", \"target\": \"temp_0\"},         {\"source\": \"swap.out_target_1\", \"target\": \"temp_1\"},         {\"source\": \"compare.out_keep\", \"target\": \"temp_2\"},         {\"source\": \"swap.out_control\", \"target\": \"temp_3\"},     ],     \"input_params\": [\"mu\", \"L\"],     \"local_variables\": [\"R=ceiling(log_2(L))\"],     \"linked_params\": [         {\"source\": \"L\", \"targets\": [\"usp.L\", \"qrom.L\", \"swap.X\"]},         {\"source\": \"mu\", \"targets\": [\"qrom.mu\", \"compare.mu\"]},     ], } In\u00a0[47]: Copied! <pre>alias_sampling_qref = {\"version\": \"v1\", \"program\": alias_sampling_dict}\n</pre> alias_sampling_qref = {\"version\": \"v1\", \"program\": alias_sampling_dict} <p>Additionally, you can examine how the circuit is represented in <code>qref</code> format by visualizing it.</p> <p>NOTE:</p> <p>         To use the qref\u00a0\u29c9 rendering tool in Jupyter Notebook, ensure the Graphviz software is installed on your OS and that its executables are included in your system variables. For installation instructions, please refer to the Graphviz download page\u00a0\u29c9.     </p> <p>Once installed, proceed to visualize the representation of the circuit.</p> In\u00a0[48]: Copied! <pre>from qref.experimental.rendering import to_graphviz\n\n# Convert the qref format to Graphviz object\ngv_object = to_graphviz(alias_sampling_qref)\n\n# Render the Graphviz object to a PNG file\ngv_object.render(\"alias_sampling\", format=\"png\")\ngv_object\n</pre> from qref.experimental.rendering import to_graphviz  # Convert the qref format to Graphviz object gv_object = to_graphviz(alias_sampling_qref)  # Render the Graphviz object to a PNG file gv_object.render(\"alias_sampling\", format=\"png\") gv_object Out[48]: <p>As we expected, the diagram displays five subroutines which are <code>usp</code>, <code>qrom</code>, <code>compare</code>, <code>had</code>, <code>swap</code>, and their hierarchical connections. Everything appears to be in order! Let's proceed with the compilation.</p> In\u00a0[49]: Copied! <pre>from bartiq.integrations import qref_to_bartiq\n\nuncompiled_routine = qref_to_bartiq(alias_sampling_qref)\n</pre> from bartiq.integrations import qref_to_bartiq  uncompiled_routine = qref_to_bartiq(alias_sampling_qref) In\u00a0[50]: Copied! <pre>from bartiq import compile_routine\n\ncompiled_routine = compile_routine(uncompiled_routine)\n</pre> from bartiq import compile_routine  compiled_routine = compile_routine(uncompiled_routine) <p>It went pretty well, let's see what's the we got:</p> In\u00a0[51]: Copied! <pre>for resource in compiled_routine.resources.values():\n    print(f\"{resource.name}: {resource.value}\")\n</pre> for resource in compiled_routine.resources.values():     print(f\"{resource.name}: {resource.value}\") <pre>T_gates: 4*L + 8*L/multiplicity(2, L) + 4*mu + swap.O(log2(L)) - 8\nrotations: 2\n</pre> <p>In the caption of Fig. 11 we had: $4(L + \\mu) + O(\\log_2(L))$, and these two expressions actually match pretty well.</p> <ul> <li>We have the $4(L + \\mu)$ in both versions.</li> <li>We have a <code>swap.O(log_2(L))</code> which corresponds to <code>O(log_2(L))</code></li> <li>The <code>8*L/multiplicity(2, L)</code> term is also <code>O(log_2(L))</code></li> <li>Constant factor of <code>-8</code> can also be incorporated in <code>O(log_2(L))</code></li> </ul> <p>Let's see how it looks like for some concrete values:</p> In\u00a0[52]: Copied! <pre>from bartiq import evaluate\n\nassignments = {\"L=120\", \"mu=8\"}\nevaluated_routine = evaluate(compiled_routine, assignments)\nfor resource in evaluated_routine.resources.values():\n    print(f\"{resource.name}: {resource.value}\")\n</pre> from bartiq import evaluate  assignments = {\"L=120\", \"mu=8\"} evaluated_routine = evaluate(compiled_routine, assignments) for resource in evaluated_routine.resources.values():     print(f\"{resource.name}: {resource.value}\") <pre>T_gates: swap.O(log2(120)) + 824\nrotations: 2\n</pre> <p>Well, we're almost there... There's still <code>swap.O()</code> in our expression \u2013 what is it?</p> <p>This is good opportunity to talk about how to substitute arbitrary functions in <code>bartiq</code>!</p> <p>As you can see, the functions in <code>bartiq</code> are namespaced by default \u2013 that's why why we have <code>swap.O</code> rather than <code>O</code>. Alternatively, you can compile your routine with <code>global_functions</code> keyword. That will remove the <code>swap.</code> namespace.</p> In\u00a0[53]: Copied! <pre>compiled_routine = compile_routine(uncompiled_routine, global_functions=[\"O\"])\nfor resource in compiled_routine.resources.values():\n    print(f\"{resource.name}: {resource.value}\")\n</pre> compiled_routine = compile_routine(uncompiled_routine, global_functions=[\"O\"]) for resource in compiled_routine.resources.values():     print(f\"{resource.name}: {resource.value}\") <pre>T_gates: 4*L + 8*L/multiplicity(2, L) + 4*mu + O(log2(L)) - 8\nrotations: 2\n</pre> <p>We still have big O there, but at least now we got rid of the <code>swap</code>. So let's assume the simplest case, i.e.<code>O(x) = ceiling(x)</code></p> In\u00a0[54]: Copied! <pre>import math\n\n\ndef big_O(x):\n    return math.ceil(x)\n\n\nfunctions_map = {\"O\": big_O}\nevaluated_routine = evaluate(compiled_routine, assignments, functions_map=functions_map)\nfor resource in evaluated_routine.resources.values():\n    print(f\"{resource.name}: {resource.value}\")\n</pre> import math   def big_O(x):     return math.ceil(x)   functions_map = {\"O\": big_O} evaluated_routine = evaluate(compiled_routine, assignments, functions_map=functions_map) for resource in evaluated_routine.resources.values():     print(f\"{resource.name}: {resource.value}\") <pre>T_gates: 831\nrotations: 2\n</pre> <p>And now we finally have some concrete numbers!</p> In\u00a0[55]: Copied! <pre>from bartiq.integrations import explore_routine\n\nexplore_routine(evaluated_routine)\n</pre> from bartiq.integrations import explore_routine  explore_routine(evaluated_routine) Out[55]: <pre>HBox(children=(_RoutineTree(multiple_selection=False, nodes=(Node(name='alias_sampling', nodes=(Node(name='com\u2026</pre> <p>If you'd prefer a static representation, you can also simply export routine to latex:</p> In\u00a0[56]: Copied! <pre>from bartiq.integrations import routine_to_latex\nfrom IPython.display import Math\n\nMath(routine_to_latex(evaluated_routine))\n</pre> from bartiq.integrations import routine_to_latex from IPython.display import Math  Math(routine_to_latex(evaluated_routine)) Out[56]:  $\\displaystyle \\begin{align} &amp;\\text{Routine \\textrm{(alias\\_sampling)}}\\newline &amp;\\underline{\\text{Input ports:}}\\\\ &amp;\\text{In\\_0} = R\\\\ &amp;\\text{In\\_1} = 8\\\\ &amp;\\text{In\\_2} = R\\\\ &amp;\\text{In\\_3} = 8\\\\ &amp;\\text{In\\_4} = 1\\newline &amp;\\underline{\\text{Output ports:}}\\\\ &amp;\\text{out\\_0} = R\\\\ &amp;\\text{temp\\_0} = 8\\\\ &amp;\\text{temp\\_1} = R\\\\ &amp;\\text{temp\\_2} = 8\\\\ &amp;\\text{temp\\_3} = 1\\newline &amp;\\underline{\\text{Resources:}}\\\\ &amp;T_{\\text{gates}} = 831\\\\ &amp;rotations = 2\\\\ &amp;\\text{usp}.\\!T_{\\text{gates}} = 320\\\\ &amp;\\text{usp}.\\!rotations = 2\\\\ &amp;\\text{qrom}.\\!T_{\\text{gates}} = 476\\\\ &amp;\\text{compare}.\\!T_{\\text{gates}} = 28\\\\ &amp;\\text{swap}.\\!T_{\\text{gates}} = 7 \\end{align}$"},{"location":"tutorials/02_alias_sampling_basic/#alias-sampling","title":"Alias Sampling\u00b6","text":""},{"location":"tutorials/02_alias_sampling_basic/#exploring-the-estimates","title":"Exploring the estimates\u00b6","text":"<p>If we just interact with bare python objects, getting a quick idea of the values of various fields might be a bit cumbersome. That's where <code>explore_routine</code> functions might be helpful. Try it out using the snippet below.</p> <p>NOTE:</p> This is an interactive feature and will not render in the static version of the docs. To use it you need to run this tutorial as a jupyter notebook.  Remember to install bartiq with <code>pip install bartiq[jupyter]</code> to make sure you have all the dependencies needed for these widgets to work (for more details visit installation docs\u00a0\u29c9)."},{"location":"tutorials/02_alias_sampling_basic/#summary","title":"Summary\u00b6","text":"<p>Let's sum up what we covered in this tutorial:</p> <ul> <li>How to take an algorithm from a paper and compile it into <code>bartiq</code></li> <li>How to create a routine with multiple resources, <code>local_variables</code> and custom functions</li> <li>How to use <code>explore_routine</code> and latex integration to get most out of <code>bartiq</code></li> </ul>"}]}